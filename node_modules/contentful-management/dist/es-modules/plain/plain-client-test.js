function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import chai, { expect } from 'chai';
import { describe } from 'mocha';
import Sinon from 'sinon';
import { createClient } from '../contentful-management';
import sinonChai from 'sinon-chai';
import { CommentNode } from '../entities/comment';
chai.should();
chai.use(sinonChai);
describe('Plain Client', () => {
  const stub = Sinon.stub();
  beforeEach(() => stub.reset());
  const apiAdapter = {
    makeRequest: args => {
      return stub.returns(Promise.resolve())(args);
    }
  };
  const plainClient = createClient({
    apiAdapter
  }, {
    type: 'plain'
  });
  describe('Comment', () => {
    describe('when body is plain text', () => {
      const props = {
        commentId: '123',
        entryId: '123',
        bodyFormat: 'plain-text'
      };
      const updateText = 'My new text';
      it('should create a get object', async () => {
        await plainClient.comment.get(props);
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'get',
          params: props,
          payload: undefined,
          headers: undefined
        });
      });
      it('should create a getMany object', async () => {
        await plainClient.comment.getMany(props);
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'getMany',
          params: props,
          payload: undefined,
          headers: undefined
        });
      });
      it('should create a create object', async () => {
        await plainClient.comment.create(props, {
          body: updateText
        });
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'create',
          params: props,
          payload: {
            body: updateText
          },
          headers: undefined
        });
      });
      it('should create a update object', async () => {
        await plainClient.comment.update(props, {
          body: updateText,
          sys: {
            version: 2
          },
          status: 'active'
        });
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'update',
          params: props,
          payload: {
            body: updateText
          },
          headers: undefined
        });
      });
      it('should create a delete object', async () => {
        await plainClient.comment.delete(_objectSpread(_objectSpread({}, props), {}, {
          version: 2
        }));
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'delete',
          params: props,
          payload: undefined,
          headers: undefined
        });
      });
    });
    describe('when body is rich text', () => {
      const richTextBody = {
        data: {},
        nodeType: CommentNode.Document,
        content: [{
          nodeType: CommentNode.Paragraph,
          data: {},
          content: [{
            nodeType: 'text',
            marks: [],
            data: {},
            value: 'My comment'
          }, {
            nodeType: CommentNode.Mention,
            data: {
              target: {
                sys: {
                  type: 'Link',
                  id: '123',
                  linkType: 'User'
                }
              }
            },
            content: [{
              nodeType: 'text',
              marks: [],
              data: {},
              value: 'My user mention'
            }]
          }, {
            nodeType: CommentNode.Mention,
            data: {
              target: {
                sys: {
                  type: 'Link',
                  id: '456',
                  linkType: 'Team'
                }
              }
            },
            content: [{
              nodeType: 'text',
              marks: [],
              data: {},
              value: 'My team mention'
            }]
          }, {
            data: {},
            marks: [],
            value: '.',
            nodeType: 'text'
          }]
        }]
      };
      const props = {
        commentId: '123',
        entryId: '123',
        bodyFormat: 'rich-text'
      };
      it('should create a get object', async () => {
        await plainClient.comment.get(props);
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'get',
          params: props,
          payload: undefined,
          headers: undefined
        });
      });
      it('should create a getMany object', async () => {
        await plainClient.comment.getMany(props);
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'getMany',
          params: props,
          payload: undefined,
          headers: undefined
        });
      });
      it('should create a create object', async () => {
        await plainClient.comment.create(props, {
          body: richTextBody
        });
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'create',
          params: props,
          payload: {
            body: richTextBody,
            status: 'active'
          },
          headers: undefined
        });
      });
      it('should create a update object', async () => {
        await plainClient.comment.update(props, {
          body: richTextBody,
          sys: {
            version: 2
          },
          status: 'active'
        });
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'update',
          params: props,
          payload: {
            body: richTextBody,
            status: 'active'
          },
          headers: undefined
        });
      });
      it('should create a delete object', async () => {
        await plainClient.comment.delete(_objectSpread(_objectSpread({}, props), {}, {
          version: 2
        }));
        expect(stub).to.have.been.calledWithMatch({
          entityType: 'Comment',
          action: 'delete',
          params: props,
          payload: undefined,
          headers: undefined
        });
      });
    });
  });
});