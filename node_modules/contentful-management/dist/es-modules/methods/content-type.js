const _excluded = ["fieldId"];
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var s = Object.getOwnPropertySymbols(e); for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }
/**
 * @private
 * @param id - unique ID of the field
 * @param key - the attribute on the field to change
 * @param value - the value to set the attribute to
 */
const findAndUpdateField = function (contentType, fieldId, omitOrDelete) {
  const field = contentType.fields.find(field => field.id === fieldId);
  if (!field) {
    return Promise.reject(new Error(`Tried to omitAndDeleteField on a nonexistent field, ${fieldId}, on the content type ${contentType.name}.`));
  }
  field[omitOrDelete] = true;
  return Promise.resolve(contentType);
};
export const omitAndDeleteField = (makeRequest, _ref, contentType) => {
  let {
      fieldId
    } = _ref,
    params = _objectWithoutProperties(_ref, _excluded);
  return findAndUpdateField(contentType, fieldId, 'omitted').then(newContentType => {
    return makeRequest({
      entityType: 'ContentType',
      action: 'update',
      params,
      payload: newContentType
    });
  }).then(newContentType => {
    return makeRequest({
      entityType: 'ContentType',
      action: 'publish',
      params,
      payload: newContentType
    });
  }).then(newContentType => {
    return findAndUpdateField(newContentType, fieldId, 'deleted');
  }).then(newContentType => {
    return makeRequest({
      entityType: 'ContentType',
      action: 'update',
      params,
      payload: newContentType
    });
  });
};