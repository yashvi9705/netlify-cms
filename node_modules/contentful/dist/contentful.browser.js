var contentful = (function (exports) {
  'use strict';

  function asyncGeneratorStep$1(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c),
        u = i.value;
    } catch (n) {
      return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator$1(n) {
    return function () {
      var t = this,
        e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n) {
          asyncGeneratorStep$1(a, r, o, _next, _throw, "next", n);
        }
        function _throw(n) {
          asyncGeneratorStep$1(a, r, o, _next, _throw, "throw", n);
        }
        _next(void 0);
      });
    };
  }

  function _arrayLikeToArray$4(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }

  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray$4(r);
  }

  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }

  function _unsupportedIterableToArray$4(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray$4(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$4(r, a) : void 0;
    }
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray$1(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray$4(r) || _nonIterableSpread();
  }

  function _arrayWithHoles$1(r) {
    if (Array.isArray(r)) return r;
  }

  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toArray(r) {
    return _arrayWithHoles$1(r) || _iterableToArray(r) || _unsupportedIterableToArray$4(r) || _nonIterableRest$1();
  }

  function _typeof$3(o) {
    "@babel/helpers - typeof";

    return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof$3(o);
  }

  function toPrimitive(t, r) {
    if ("object" != _typeof$3(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _typeof$3(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }

  function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof$3(i) ? i : i + "";
  }

  function _defineProperty$1(e, r, t) {
    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }

  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }

  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }

  function _iterableToArrayLimit$1(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }

  function _slicedToArray$2(r, e) {
    return _arrayWithHoles$1(r) || _iterableToArrayLimit$1(r, e) || _unsupportedIterableToArray$4(r, e) || _nonIterableRest$1();
  }

  function _OverloadYield(e, d) {
    this.v = e, this.k = d;
  }

  function _wrapAsyncGenerator(e) {
    return function () {
      return new AsyncGenerator(e.apply(this, arguments));
    };
  }
  function AsyncGenerator(e) {
    var r, t;
    function resume(r, t) {
      try {
        var n = e[r](t),
          o = n.value,
          u = o instanceof _OverloadYield;
        Promise.resolve(u ? o.v : o).then(function (t) {
          if (u) {
            var i = "return" === r ? "return" : "next";
            if (!o.k || t.done) return resume(i, t);
            t = e[i](t).value;
          }
          settle(n.done ? "return" : "normal", t);
        }, function (e) {
          resume("throw", e);
        });
      } catch (e) {
        settle("throw", e);
      }
    }
    function settle(e, n) {
      switch (e) {
        case "return":
          r.resolve({
            value: n,
            done: !0
          });
          break;
        case "throw":
          r.reject(n);
          break;
        default:
          r.resolve({
            value: n,
            done: !1
          });
      }
      (r = r.next) ? resume(r.key, r.arg) : t = null;
    }
    this._invoke = function (e, n) {
      return new Promise(function (o, u) {
        var i = {
          key: e,
          arg: n,
          resolve: o,
          reject: u,
          next: null
        };
        t ? t = t.next = i : (r = t = i, resume(e, n));
      });
    }, "function" != typeof e["return"] && (this["return"] = void 0);
  }
  AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () {
    return this;
  }, AsyncGenerator.prototype.next = function (e) {
    return this._invoke("next", e);
  }, AsyncGenerator.prototype["throw"] = function (e) {
    return this._invoke("throw", e);
  }, AsyncGenerator.prototype["return"] = function (e) {
    return this._invoke("return", e);
  };

  function _awaitAsyncGenerator(e) {
    return new _OverloadYield(e, 0);
  }

  function _asyncGeneratorDelegate(t) {
    var e = {},
      n = !1;
    function pump(e, r) {
      return n = !0, r = new Promise(function (n) {
        n(t[e](r));
      }), {
        done: !1,
        value: new _OverloadYield(r, 1)
      };
    }
    return e["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () {
      return this;
    }, e.next = function (t) {
      return n ? (n = !1, t) : pump("next", t);
    }, "function" == typeof t["throw"] && (e["throw"] = function (t) {
      if (n) throw n = !1, t;
      return pump("throw", t);
    }), "function" == typeof t["return"] && (e["return"] = function (t) {
      return n ? (n = !1, t) : pump("return", t);
    }), e;
  }

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getDefaultExportFromNamespaceIfNotNamed (n) {
  	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
  }

  var regeneratorRuntime$1 = {exports: {}};

  var _typeof$2 = {exports: {}};

  (function (module) {
    function _typeof(o) {
      "@babel/helpers - typeof";

      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
        return typeof o;
      } : function (o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof$2);
  var _typeofExports = _typeof$2.exports;

  (function (module) {
    var _typeof = _typeofExports["default"];
    function _regeneratorRuntime() {

      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return e;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var t,
        e = {},
        r = Object.prototype,
        n = r.hasOwnProperty,
        o = Object.defineProperty || function (t, e, r) {
          t[e] = r.value;
        },
        i = "function" == typeof Symbol ? Symbol : {},
        a = i.iterator || "@@iterator",
        c = i.asyncIterator || "@@asyncIterator",
        u = i.toStringTag || "@@toStringTag";
      function define(t, e, r) {
        return Object.defineProperty(t, e, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), t[e];
      }
      try {
        define({}, "");
      } catch (t) {
        define = function define(t, e, r) {
          return t[e] = r;
        };
      }
      function wrap(t, e, r, n) {
        var i = e && e.prototype instanceof Generator ? e : Generator,
          a = Object.create(i.prototype),
          c = new Context(n || []);
        return o(a, "_invoke", {
          value: makeInvokeMethod(t, r, c)
        }), a;
      }
      function tryCatch(t, e, r) {
        try {
          return {
            type: "normal",
            arg: t.call(e, r)
          };
        } catch (t) {
          return {
            type: "throw",
            arg: t
          };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart",
        l = "suspendedYield",
        f = "executing",
        s = "completed",
        y = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var p = {};
      define(p, a, function () {
        return this;
      });
      var d = Object.getPrototypeOf,
        v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t) {
        ["next", "throw", "return"].forEach(function (e) {
          define(t, e, function (t) {
            return this._invoke(e, t);
          });
        });
      }
      function AsyncIterator(t, e) {
        function invoke(r, o, i, a) {
          var c = tryCatch(t[r], t, o);
          if ("throw" !== c.type) {
            var u = c.arg,
              h = u.value;
            return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
              invoke("next", t, i, a);
            }, function (t) {
              invoke("throw", t, i, a);
            }) : e.resolve(h).then(function (t) {
              u.value = t, i(u);
            }, function (t) {
              return invoke("throw", t, i, a);
            });
          }
          a(c.arg);
        }
        var r;
        o(this, "_invoke", {
          value: function value(t, n) {
            function callInvokeWithMethodAndArg() {
              return new e(function (e, r) {
                invoke(t, n, e, r);
              });
            }
            return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e, r, n) {
        var o = h;
        return function (i, a) {
          if (o === f) throw Error("Generator is already running");
          if (o === s) {
            if ("throw" === i) throw a;
            return {
              value: t,
              done: !0
            };
          }
          for (n.method = i, n.arg = a;;) {
            var c = n.delegate;
            if (c) {
              var u = maybeInvokeDelegate(c, n);
              if (u) {
                if (u === y) continue;
                return u;
              }
            }
            if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
              if (o === h) throw o = s, n.arg;
              n.dispatchException(n.arg);
            } else "return" === n.method && n.abrupt("return", n.arg);
            o = f;
            var p = tryCatch(e, r, n);
            if ("normal" === p.type) {
              if (o = n.done ? s : l, p.arg === y) continue;
              return {
                value: p.arg,
                done: n.done
              };
            }
            "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
          }
        };
      }
      function maybeInvokeDelegate(e, r) {
        var n = r.method,
          o = e.iterator[n];
        if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
        var i = tryCatch(o, e.iterator, r.arg);
        if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
        var a = i.arg;
        return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
      }
      function pushTryEntry(t) {
        var e = {
          tryLoc: t[0]
        };
        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
      }
      function resetTryEntry(t) {
        var e = t.completion || {};
        e.type = "normal", delete e.arg, t.completion = e;
      }
      function Context(t) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t.forEach(pushTryEntry, this), this.reset(!0);
      }
      function values(e) {
        if (e || "" === e) {
          var r = e[a];
          if (r) return r.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length)) {
            var o = -1,
              i = function next() {
                for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
                return next.value = t, next.done = !0, next;
              };
            return i.next = i;
          }
        }
        throw new TypeError(_typeof(e) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
      }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
        var e = "function" == typeof t && t.constructor;
        return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
      }, e.mark = function (t) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
      }, e.awrap = function (t) {
        return {
          __await: t
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
        void 0 === i && (i = Promise);
        var a = new AsyncIterator(wrap(t, r, n, o), i);
        return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
          return t.done ? t.value : a.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
        return this;
      }), define(g, "toString", function () {
        return "[object Generator]";
      }), e.keys = function (t) {
        var e = Object(t),
          r = [];
        for (var n in e) r.push(n);
        return r.reverse(), function next() {
          for (; r.length;) {
            var t = r.pop();
            if (t in e) return next.value = t, next.done = !1, next;
          }
          return next.done = !0, next;
        };
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
        },
        stop: function stop() {
          this.done = !0;
          var t = this.tryEntries[0].completion;
          if ("throw" === t.type) throw t.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e) {
          if (this.done) throw e;
          var r = this;
          function handle(n, o) {
            return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
          }
          for (var o = this.tryEntries.length - 1; o >= 0; --o) {
            var i = this.tryEntries[o],
              a = i.completion;
            if ("root" === i.tryLoc) return handle("end");
            if (i.tryLoc <= this.prev) {
              var c = n.call(i, "catchLoc"),
                u = n.call(i, "finallyLoc");
              if (c && u) {
                if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
              } else if (c) {
                if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              } else {
                if (!u) throw Error("try statement without catch or finally");
                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t, e) {
          for (var r = this.tryEntries.length - 1; r >= 0; --r) {
            var o = this.tryEntries[r];
            if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
              var i = o;
              break;
            }
          }
          i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
          var a = i ? i.completion : {};
          return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
        },
        complete: function complete(t, e) {
          if ("throw" === t.type) throw t.arg;
          return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
        },
        finish: function finish(t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var r = this.tryEntries[e];
            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
          }
        },
        "catch": function _catch(t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var r = this.tryEntries[e];
            if (r.tryLoc === t) {
              var n = r.completion;
              if ("throw" === n.type) {
                var o = n.arg;
                resetTryEntry(r);
              }
              return o;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e, r, n) {
          return this.delegate = {
            iterator: values(e),
            resultName: r,
            nextLoc: n
          }, "next" === this.method && (this.arg = t), y;
        }
      }, e;
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);
  var regeneratorRuntimeExports = regeneratorRuntime$1.exports;

  // TODO(Babel 8): Remove this file.

  var runtime = regeneratorRuntimeExports();
  var regenerator = runtime;

  // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof$3(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }
  var _regeneratorRuntime$1 = /*@__PURE__*/getDefaultExportFromCjs(regenerator);

  function _createForOfIteratorHelper$3(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$3(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
  function _unsupportedIterableToArray$3(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$3(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$3(r, a) : void 0; } }
  function _arrayLikeToArray$3(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
  function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty$1(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
  function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
  function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function _return(r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function _throw(r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); }
  function bind$2(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }

  // utils is a library of generic helper functions non-specific to axios

  var toString = Object.prototype.toString;
  var getPrototypeOf = Object.getPrototypeOf;
  var kindOf = function (cache) {
    return function (thing) {
      var str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    };
  }(Object.create(null));
  var kindOfTest = function kindOfTest(type) {
    type = type.toLowerCase();
    return function (thing) {
      return kindOf(thing) === type;
    };
  };
  var typeOfTest = function typeOfTest(type) {
    return function (thing) {
      return _typeof$3(thing) === type;
    };
  };

  /**
   * Determine if a value is an Array
   *
   * @param {Object} val The value to test
   *
   * @returns {boolean} True if value is an Array, otherwise false
   */
  var isArray$5 = Array.isArray;

  /**
   * Determine if a value is undefined
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if the value is undefined, otherwise false
   */
  var isUndefined = typeOfTest('undefined');

  /**
   * Determine if a value is a Buffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Buffer, otherwise false
   */
  function isBuffer$1(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }

  /**
   * Determine if a value is an ArrayBuffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is an ArrayBuffer, otherwise false
   */
  var isArrayBuffer = kindOfTest('ArrayBuffer');

  /**
   * Determine if a value is a view on an ArrayBuffer
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
   */
  function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }

  /**
   * Determine if a value is a String
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a String, otherwise false
   */
  var isString$3 = typeOfTest('string');

  /**
   * Determine if a value is a Function
   *
   * @param {*} val The value to test
   * @returns {boolean} True if value is a Function, otherwise false
   */
  var isFunction = typeOfTest('function');

  /**
   * Determine if a value is a Number
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Number, otherwise false
   */
  var isNumber$1 = typeOfTest('number');

  /**
   * Determine if a value is an Object
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an Object, otherwise false
   */
  var isObject = function isObject(thing) {
    return thing !== null && _typeof$3(thing) === 'object';
  };

  /**
   * Determine if a value is a Boolean
   *
   * @param {*} thing The value to test
   * @returns {boolean} True if value is a Boolean, otherwise false
   */
  var isBoolean$1 = function isBoolean(thing) {
    return thing === true || thing === false;
  };

  /**
   * Determine if a value is a plain Object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a plain Object, otherwise false
   */
  var isPlainObject$2 = function isPlainObject(val) {
    if (kindOf(val) !== 'object') {
      return false;
    }
    var prototype = getPrototypeOf(val);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };

  /**
   * Determine if a value is a Date
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Date, otherwise false
   */
  var isDate$1 = kindOfTest('Date');

  /**
   * Determine if a value is a File
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a File, otherwise false
   */
  var isFile = kindOfTest('File');

  /**
   * Determine if a value is a Blob
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Blob, otherwise false
   */
  var isBlob = kindOfTest('Blob');

  /**
   * Determine if a value is a FileList
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a File, otherwise false
   */
  var isFileList = kindOfTest('FileList');

  /**
   * Determine if a value is a Stream
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a Stream, otherwise false
   */
  var isStream = function isStream(val) {
    return isObject(val) && isFunction(val.pipe);
  };

  /**
   * Determine if a value is a FormData
   *
   * @param {*} thing The value to test
   *
   * @returns {boolean} True if value is an FormData, otherwise false
   */
  var isFormData = function isFormData(thing) {
    var kind;
    return thing && (typeof FormData === 'function' && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === 'formdata' ||
    // detect form-data instance
    kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]'));
  };

  /**
   * Determine if a value is a URLSearchParams object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a URLSearchParams object, otherwise false
   */
  var isURLSearchParams = kindOfTest('URLSearchParams');
  var _map = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest),
    _map2 = _slicedToArray$2(_map, 4),
    isReadableStream = _map2[0],
    isRequest = _map2[1],
    isResponse = _map2[2],
    isHeaders = _map2[3];

  /**
   * Trim excess whitespace off the beginning and end of a string
   *
   * @param {String} str The String to trim
   *
   * @returns {String} The String freed of excess whitespace
   */
  var trim = function trim(str) {
    return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  };

  /**
   * Iterate over an Array or an Object invoking a function for each item.
   *
   * If `obj` is an Array callback will be called passing
   * the value, index, and complete array for each item.
   *
   * If 'obj' is an Object callback will be called passing
   * the value, key, and complete object for each property.
   *
   * @param {Object|Array} obj The object to iterate
   * @param {Function} fn The callback to invoke for each item
   *
   * @param {Boolean} [allOwnKeys = false]
   * @returns {any}
   */
  function forEach(obj, fn) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref3$allOwnKeys = _ref3.allOwnKeys,
      allOwnKeys = _ref3$allOwnKeys === void 0 ? false : _ref3$allOwnKeys;
    // Don't bother if no value provided
    if (obj === null || typeof obj === 'undefined') {
      return;
    }
    var i;
    var l;

    // Force an array if not already something iterable
    if (_typeof$3(obj) !== 'object') {
      /*eslint no-param-reassign:0*/
      obj = [obj];
    }
    if (isArray$5(obj)) {
      // Iterate over array values
      for (i = 0, l = obj.length; i < l; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      // Iterate over object keys
      var keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      var len = keys.length;
      var key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    var keys = Object.keys(obj);
    var i = keys.length;
    var _key;
    while (i-- > 0) {
      _key = keys[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  var _global = function () {
    /*eslint no-undef:0*/
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== 'undefined' ? window : global;
  }();
  var isContextDefined = function isContextDefined(context) {
    return !isUndefined(context) && context !== _global;
  };

  /**
   * Accepts varargs expecting each argument to be an object, then
   * immutably merges the properties of each object and returns result.
   *
   * When multiple objects contain the same key the later object in
   * the arguments list will take precedence.
   *
   * Example:
   *
   * ```js
   * var result = merge({foo: 123}, {foo: 456});
   * console.log(result.foo); // outputs 456
   * ```
   *
   * @param {Object} obj1 Object to merge
   *
   * @returns {Object} Result of all merge properties
   */
  function merge$1(/* obj1, obj2, obj3, ... */
  ) {
    var _ref4 = isContextDefined(this) && this || {},
      caseless = _ref4.caseless;
    var result = {};
    var assignValue = function assignValue(val, key) {
      var targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject$2(result[targetKey]) && isPlainObject$2(val)) {
        result[targetKey] = merge$1(result[targetKey], val);
      } else if (isPlainObject$2(val)) {
        result[targetKey] = merge$1({}, val);
      } else if (isArray$5(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (var i = 0, l = arguments.length; i < l; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }

  /**
   * Extends object a by mutably adding to it the properties of object b.
   *
   * @param {Object} a The object to be extended
   * @param {Object} b The object to copy properties from
   * @param {Object} thisArg The object to bind function to
   *
   * @param {Boolean} [allOwnKeys]
   * @returns {Object} The resulting value of object a
   */
  var extend = function extend(a, b, thisArg) {
    var _ref5 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      allOwnKeys = _ref5.allOwnKeys;
    forEach(b, function (val, key) {
      if (thisArg && isFunction(val)) {
        a[key] = bind$2(val, thisArg);
      } else {
        a[key] = val;
      }
    }, {
      allOwnKeys: allOwnKeys
    });
    return a;
  };

  /**
   * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
   *
   * @param {string} content with BOM
   *
   * @returns {string} content value without BOM
   */
  var stripBOM = function stripBOM(content) {
    if (content.charCodeAt(0) === 0xFEFF) {
      content = content.slice(1);
    }
    return content;
  };

  /**
   * Inherit the prototype methods from one constructor into another
   * @param {function} constructor
   * @param {function} superConstructor
   * @param {object} [props]
   * @param {object} [descriptors]
   *
   * @returns {void}
   */
  var inherits = function inherits(constructor, superConstructor, props, descriptors) {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, 'super', {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };

  /**
   * Resolve object with deep prototype chain to a flat object
   * @param {Object} sourceObj source object
   * @param {Object} [destObj]
   * @param {Function|Boolean} [filter]
   * @param {Function} [propFilter]
   *
   * @returns {Object}
   */
  var toFlatObject = function toFlatObject(sourceObj, destObj, filter, propFilter) {
    var props;
    var i;
    var prop;
    var merged = {};
    destObj = destObj || {};
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (sourceObj == null) return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };

  /**
   * Determines whether a string ends with the characters of a specified string
   *
   * @param {String} str
   * @param {String} searchString
   * @param {Number} [position= 0]
   *
   * @returns {boolean}
   */
  var endsWith = function endsWith(str, searchString, position) {
    str = String(str);
    if (position === undefined || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    var lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };

  /**
   * Returns new array from array like object or null if failed
   *
   * @param {*} [thing]
   *
   * @returns {?Array}
   */
  var toArray = function toArray(thing) {
    if (!thing) return null;
    if (isArray$5(thing)) return thing;
    var i = thing.length;
    if (!isNumber$1(i)) return null;
    var arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };

  /**
   * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
   * thing passed in is an instance of Uint8Array
   *
   * @param {TypedArray}
   *
   * @returns {Array}
   */
  // eslint-disable-next-line func-names
  var isTypedArray = function (TypedArray) {
    // eslint-disable-next-line func-names
    return function (thing) {
      return TypedArray && thing instanceof TypedArray;
    };
  }(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

  /**
   * For each entry in the object, call the function with the key and value.
   *
   * @param {Object<any, any>} obj - The object to iterate over.
   * @param {Function} fn - The function to call for each entry.
   *
   * @returns {void}
   */
  var forEachEntry = function forEachEntry(obj, fn) {
    var generator = obj && obj[Symbol.iterator];
    var iterator = generator.call(obj);
    var result;
    while ((result = iterator.next()) && !result.done) {
      var pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };

  /**
   * It takes a regular expression and a string, and returns an array of all the matches
   *
   * @param {string} regExp - The regular expression to match against.
   * @param {string} str - The string to search.
   *
   * @returns {Array<boolean>}
   */
  var matchAll = function matchAll(regExp, str) {
    var matches;
    var arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };

  /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
  var isHTMLForm = kindOfTest('HTMLFormElement');
  var toCamelCase = function toCamelCase(str) {
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    });
  };

  /* Creating a function that will check if an object has a property. */
  var hasOwnProperty$1 = function (_ref6) {
    var hasOwnProperty = _ref6.hasOwnProperty;
    return function (obj, prop) {
      return hasOwnProperty.call(obj, prop);
    };
  }(Object.prototype);

  /**
   * Determine if a value is a RegExp object
   *
   * @param {*} val The value to test
   *
   * @returns {boolean} True if value is a RegExp object, otherwise false
   */
  var isRegExp$2 = kindOfTest('RegExp');
  var reduceDescriptors = function reduceDescriptors(obj, reducer) {
    var descriptors = Object.getOwnPropertyDescriptors(obj);
    var reducedDescriptors = {};
    forEach(descriptors, function (descriptor, name) {
      var ret;
      if ((ret = reducer(descriptor, name, obj)) !== false) {
        reducedDescriptors[name] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };

  /**
   * Makes all methods read-only
   * @param {Object} obj
   */

  var freezeMethods = function freezeMethods(obj) {
    reduceDescriptors(obj, function (descriptor, name) {
      // skip restricted props in strict mode
      if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
        return false;
      }
      var value = obj[name];
      if (!isFunction(value)) return;
      descriptor.enumerable = false;
      if ('writable' in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = function () {
          throw Error('Can not rewrite read-only method \'' + name + '\'');
        };
      }
    });
  };
  var toObjectSet = function toObjectSet(arrayOrString, delimiter) {
    var obj = {};
    var define = function define(arr) {
      arr.forEach(function (value) {
        obj[value] = true;
      });
    };
    isArray$5(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
  };
  var noop$1 = function noop() {};
  var toFiniteNumber = function toFiniteNumber(value, defaultValue) {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
  };
  var ALPHA = 'abcdefghijklmnopqrstuvwxyz';
  var DIGIT = '0123456789';
  var ALPHABET = {
    DIGIT: DIGIT,
    ALPHA: ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  var generateString = function generateString() {
    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
    var alphabet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ALPHABET.ALPHA_DIGIT;
    var str = '';
    var length = alphabet.length;
    while (size--) {
      str += alphabet[Math.random() * length | 0];
    }
    return str;
  };

  /**
   * If the thing is a FormData object, return true, otherwise return false.
   *
   * @param {unknown} thing - The thing to check.
   *
   * @returns {boolean}
   */
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === 'FormData' && thing[Symbol.iterator]);
  }
  var toJSONObject = function toJSONObject(obj) {
    var stack = new Array(10);
    var _visit = function visit(source, i) {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!('toJSON' in source)) {
          stack[i] = source;
          var target = isArray$5(source) ? [] : {};
          forEach(source, function (value, key) {
            var reducedValue = _visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i] = undefined;
          return target;
        }
      }
      return source;
    };
    return _visit(obj, 0);
  };
  var isAsyncFn = kindOfTest('AsyncFunction');
  var isThenable = function isThenable(thing) {
    return thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
  };

  // original code
  // https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

  var _setImmediate = function (setImmediateSupported, postMessageSupported) {
    if (setImmediateSupported) {
      return setImmediate;
    }
    return postMessageSupported ? function (token, callbacks) {
      _global.addEventListener("message", function (_ref7) {
        var source = _ref7.source,
          data = _ref7.data;
        if (source === _global && data === token) {
          callbacks.length && callbacks.shift()();
        }
      }, false);
      return function (cb) {
        callbacks.push(cb);
        _global.postMessage(token, "*");
      };
    }("axios@".concat(Math.random()), []) : function (cb) {
      return setTimeout(cb);
    };
  }(typeof setImmediate === 'function', isFunction(_global.postMessage));
  var asap = typeof queueMicrotask !== 'undefined' ? queueMicrotask.bind(_global) : typeof process !== 'undefined' && process.nextTick || _setImmediate;

  // *********************

  var utils$1$1 = {
    isArray: isArray$5,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer$1,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString$3,
    isNumber: isNumber$1,
    isBoolean: isBoolean$1,
    isObject: isObject,
    isPlainObject: isPlainObject$2,
    isReadableStream: isReadableStream,
    isRequest: isRequest,
    isResponse: isResponse,
    isHeaders: isHeaders,
    isUndefined: isUndefined,
    isDate: isDate$1,
    isFile: isFile,
    isBlob: isBlob,
    isRegExp: isRegExp$2,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isTypedArray: isTypedArray,
    isFileList: isFileList,
    forEach: forEach,
    merge: merge$1,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM,
    inherits: inherits,
    toFlatObject: toFlatObject,
    kindOf: kindOf,
    kindOfTest: kindOfTest,
    endsWith: endsWith,
    toArray: toArray,
    forEachEntry: forEachEntry,
    matchAll: matchAll,
    isHTMLForm: isHTMLForm,
    hasOwnProperty: hasOwnProperty$1,
    hasOwnProp: hasOwnProperty$1,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: reduceDescriptors,
    freezeMethods: freezeMethods,
    toObjectSet: toObjectSet,
    toCamelCase: toCamelCase,
    noop: noop$1,
    toFiniteNumber: toFiniteNumber,
    findKey: findKey,
    global: _global,
    isContextDefined: isContextDefined,
    ALPHABET: ALPHABET,
    generateString: generateString,
    isSpecCompliantForm: isSpecCompliantForm,
    toJSONObject: toJSONObject,
    isAsyncFn: isAsyncFn,
    isThenable: isThenable,
    setImmediate: _setImmediate,
    asap: asap
  };

  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [config] The config.
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   *
   * @returns {Error} The created error.
   */
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = 'AxiosError';
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status ? response.status : null;
    }
  }
  utils$1$1.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils$1$1.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  var prototype$1 = AxiosError.prototype;
  var descriptors = {};
  ['ERR_BAD_OPTION_VALUE', 'ERR_BAD_OPTION', 'ECONNABORTED', 'ETIMEDOUT', 'ERR_NETWORK', 'ERR_FR_TOO_MANY_REDIRECTS', 'ERR_DEPRECATED', 'ERR_BAD_RESPONSE', 'ERR_BAD_REQUEST', 'ERR_CANCELED', 'ERR_NOT_SUPPORT', 'ERR_INVALID_URL'
  // eslint-disable-next-line func-names
  ].forEach(function (code) {
    descriptors[code] = {
      value: code
    };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, 'isAxiosError', {
    value: true
  });

  // eslint-disable-next-line func-names
  AxiosError.from = function (error, code, config, request, response, customProps) {
    var axiosError = Object.create(prototype$1);
    utils$1$1.toFlatObject(error, axiosError, function filter(obj) {
      return obj !== Error.prototype;
    }, function (prop) {
      return prop !== 'isAxiosError';
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };

  // eslint-disable-next-line strict
  var httpAdapter = null;

  /**
   * Determines if the given thing is a array or js object.
   *
   * @param {string} thing - The object or array to be visited.
   *
   * @returns {boolean}
   */
  function isVisitable(thing) {
    return utils$1$1.isPlainObject(thing) || utils$1$1.isArray(thing);
  }

  /**
   * It removes the brackets from the end of a string
   *
   * @param {string} key - The key of the parameter.
   *
   * @returns {string} the key without the brackets.
   */
  function removeBrackets(key) {
    return utils$1$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
  }

  /**
   * It takes a path, a key, and a boolean, and returns a string
   *
   * @param {string} path - The path to the current key.
   * @param {string} key - The key of the current object being iterated over.
   * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
   *
   * @returns {string} The path to the current key.
   */
  function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
      // eslint-disable-next-line no-param-reassign
      token = removeBrackets(token);
      return !dots && i ? '[' + token + ']' : token;
    }).join(dots ? '.' : '');
  }

  /**
   * If the array is an array and none of its elements are visitable, then it's a flat array.
   *
   * @param {Array<any>} arr - The array to check
   *
   * @returns {boolean}
   */
  function isFlatArray(arr) {
    return utils$1$1.isArray(arr) && !arr.some(isVisitable);
  }
  var predicates = utils$1$1.toFlatObject(utils$1$1, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });

  /**
   * Convert a data object to FormData
   *
   * @param {Object} obj
   * @param {?Object} [formData]
   * @param {?Object} [options]
   * @param {Function} [options.visitor]
   * @param {Boolean} [options.metaTokens = true]
   * @param {Boolean} [options.dots = false]
   * @param {?Boolean} [options.indexes = false]
   *
   * @returns {Object}
   **/

  /**
   * It converts an object into a FormData object
   *
   * @param {Object<any, any>} obj - The object to convert to form data.
   * @param {string} formData - The FormData object to append to.
   * @param {Object<string, any>} options
   *
   * @returns
   */
  function toFormData(obj, formData, options) {
    if (!utils$1$1.isObject(obj)) {
      throw new TypeError('target must be an object');
    }

    // eslint-disable-next-line no-param-reassign
    formData = formData || new FormData();

    // eslint-disable-next-line no-param-reassign
    options = utils$1$1.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      // eslint-disable-next-line no-eq-null,eqeqeq
      return !utils$1$1.isUndefined(source[option]);
    });
    var metaTokens = options.metaTokens;
    // eslint-disable-next-line no-use-before-define
    var visitor = options.visitor || defaultVisitor;
    var dots = options.dots;
    var indexes = options.indexes;
    var _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
    var useBlob = _Blob && utils$1$1.isSpecCompliantForm(formData);
    if (!utils$1$1.isFunction(visitor)) {
      throw new TypeError('visitor must be a function');
    }
    function convertValue(value) {
      if (value === null) return '';
      if (utils$1$1.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils$1$1.isBlob(value)) {
        throw new AxiosError('Blob is not supported. Use a Buffer instead.');
      }
      if (utils$1$1.isArrayBuffer(value) || utils$1$1.isTypedArray(value)) {
        return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }

    /**
     * Default visitor.
     *
     * @param {*} value
     * @param {String|Number} key
     * @param {Array<String|Number>} path
     * @this {FormData}
     *
     * @returns {boolean} return true to visit the each prop of the value recursively
     */
    function defaultVisitor(value, key, path) {
      var arr = value;
      if (value && !path && _typeof$3(value) === 'object') {
        if (utils$1$1.endsWith(key, '{}')) {
          // eslint-disable-next-line no-param-reassign
          key = metaTokens ? key : key.slice(0, -2);
          // eslint-disable-next-line no-param-reassign
          value = JSON.stringify(value);
        } else if (utils$1$1.isArray(value) && isFlatArray(value) || (utils$1$1.isFileList(value) || utils$1$1.endsWith(key, '[]')) && (arr = utils$1$1.toArray(value))) {
          // eslint-disable-next-line no-param-reassign
          key = removeBrackets(key);
          arr.forEach(function each(el, index) {
            !(utils$1$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + '[]', convertValue(el));
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key, dots), convertValue(value));
      return false;
    }
    var stack = [];
    var exposedHelpers = Object.assign(predicates, {
      defaultVisitor: defaultVisitor,
      convertValue: convertValue,
      isVisitable: isVisitable
    });
    function build(value, path) {
      if (utils$1$1.isUndefined(value)) return;
      if (stack.indexOf(value) !== -1) {
        throw Error('Circular reference detected in ' + path.join('.'));
      }
      stack.push(value);
      utils$1$1.forEach(value, function each(el, key) {
        var result = !(utils$1$1.isUndefined(el) || el === null) && visitor.call(formData, el, utils$1$1.isString(key) ? key.trim() : key, path, exposedHelpers);
        if (result === true) {
          build(el, path ? path.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils$1$1.isObject(obj)) {
      throw new TypeError('data must be an object');
    }
    build(obj);
    return formData;
  }

  /**
   * It encodes a string by replacing all characters that are not in the unreserved set with
   * their percent-encoded equivalents
   *
   * @param {string} str - The string to encode.
   *
   * @returns {string} The encoded string.
   */
  function encode$1(str) {
    var charMap = {
      '!': '%21',
      "'": '%27',
      '(': '%28',
      ')': '%29',
      '~': '%7E',
      '%20': '+',
      '%00': '\x00'
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }

  /**
   * It takes a params object and converts it to a FormData object
   *
   * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
   * @param {Object<string, any>} options - The options object passed to the Axios constructor.
   *
   * @returns {void}
   */
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  var prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString(encoder) {
    var _encode = encoder ? function (value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + '=' + _encode(pair[1]);
    }, '').join('&');
  };

  /**
   * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
   * URI encoded counterparts
   *
   * @param {string} val The value to be encoded.
   *
   * @returns {string} The encoded value.
   */
  function encode$2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
  }

  /**
   * Build a URL by appending params to the end
   *
   * @param {string} url The base of the url (e.g., http://www.google.com)
   * @param {object} [params] The params to be appended
   * @param {?object} options
   *
   * @returns {string} The formatted url
   */
  function buildURL(url, params, options) {
    /*eslint no-param-reassign:0*/
    if (!params) {
      return url;
    }
    var _encode = options && options.encode || encode$2;
    var serializeFn = options && options.serialize;
    var serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils$1$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
    }
    return url;
  }
  var InterceptorManager = /*#__PURE__*/function () {
    function InterceptorManager() {
      _classCallCheck(this, InterceptorManager);
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    return _createClass(InterceptorManager, [{
      key: "use",
      value: function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled: fulfilled,
          rejected: rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }

      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
    }, {
      key: "eject",
      value: function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }

      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
    }, {
      key: "clear",
      value: function clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }

      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
    }, {
      key: "forEach",
      value: function forEach(fn) {
        utils$1$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    }]);
  }();
  var InterceptorManager$1 = InterceptorManager;
  var transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;
  var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;
  var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;
  var platform$1 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
  };
  var hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';
  var _navigator = (typeof navigator === "undefined" ? "undefined" : _typeof$3(navigator)) === 'object' && navigator || undefined;

  /**
   * Determine if we're running in a standard browser environment
   *
   * This allows axios to run in a web worker, and react-native.
   * Both environments support XMLHttpRequest, but not fully standard globals.
   *
   * web workers:
   *  typeof window -> undefined
   *  typeof document -> undefined
   *
   * react-native:
   *  navigator.product -> 'ReactNative'
   * nativescript
   *  navigator.product -> 'NativeScript' or 'NS'
   *
   * @returns {boolean}
   */
  var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

  /**
   * Determine if we're running in a standard browser webWorker environment
   *
   * Although the `isStandardBrowserEnv` method indicates that
   * `allows axios to run in a web worker`, the WebWorker will still be
   * filtered out due to its judgment standard
   * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
   * This leads to a problem when axios post `FormData` in webWorker
   */
  var hasStandardBrowserWebWorkerEnv = function () {
    return typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === 'function';
  }();
  var origin = hasBrowserEnv && window.location.href || 'http://localhost';
  var utils$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    hasBrowserEnv: hasBrowserEnv,
    hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
    hasStandardBrowserEnv: hasStandardBrowserEnv,
    navigator: _navigator,
    origin: origin
  });
  var platform = _objectSpread(_objectSpread({}, utils$3), platform$1);
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function visitor(value, key, path, helpers) {
        if (platform.isNode && utils$1$1.isBuffer(value)) {
          this.append(key, value.toString('base64'));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }

  /**
   * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
   *
   * @param {string} name - The name of the property to get.
   *
   * @returns An array of strings.
   */
  function parsePropPath(name) {
    // foo[x][y][z]
    // foo.x.y.z
    // foo-x-y-z
    // foo x y z
    return utils$1$1.matchAll(/\w+|\[(\w*)]/g, name).map(function (match) {
      return match[0] === '[]' ? '' : match[1] || match[0];
    });
  }

  /**
   * Convert an array to an object.
   *
   * @param {Array<any>} arr - The array to convert to an object.
   *
   * @returns An object with the same keys and values as the array.
   */
  function arrayToObject$1(arr) {
    var obj = {};
    var keys = Object.keys(arr);
    var i;
    var len = keys.length;
    var key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      obj[key] = arr[key];
    }
    return obj;
  }

  /**
   * It takes a FormData object and returns a JavaScript object
   *
   * @param {string} formData The FormData object to convert to JSON.
   *
   * @returns {Object<string, any> | null} The converted object.
   */
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
      var name = path[index++];
      if (name === '__proto__') return true;
      var isNumericKey = Number.isFinite(+name);
      var isLast = index >= path.length;
      name = !name && utils$1$1.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils$1$1.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils$1$1.isObject(target[name])) {
        target[name] = [];
      }
      var result = buildPath(path, value, target[name], index);
      if (result && utils$1$1.isArray(target[name])) {
        target[name] = arrayToObject$1(target[name]);
      }
      return !isNumericKey;
    }
    if (utils$1$1.isFormData(formData) && utils$1$1.isFunction(formData.entries)) {
      var obj = {};
      utils$1$1.forEachEntry(formData, function (name, value) {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }

  /**
   * It takes a string, tries to parse it, and if it fails, it returns the stringified version
   * of the input
   *
   * @param {any} rawValue - The value to be stringified.
   * @param {Function} parser - A function that parses a string into a JavaScript object.
   * @param {Function} encoder - A function that takes a value and returns a string.
   *
   * @returns {string} A stringified version of the rawValue.
   */
  function stringifySafely(rawValue, parser, encoder) {
    if (utils$1$1.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils$1$1.trim(rawValue);
      } catch (e) {
        if (e.name !== 'SyntaxError') {
          throw e;
        }
      }
    }
    return (0, JSON.stringify)(rawValue);
  }
  var defaults$2 = {
    transitional: transitionalDefaults,
    adapter: ['xhr', 'http', 'fetch'],
    transformRequest: [function transformRequest(data, headers) {
      var contentType = headers.getContentType() || '';
      var hasJSONContentType = contentType.indexOf('application/json') > -1;
      var isObjectPayload = utils$1$1.isObject(data);
      if (isObjectPayload && utils$1$1.isHTMLForm(data)) {
        data = new FormData(data);
      }
      var isFormData = utils$1$1.isFormData(data);
      if (isFormData) {
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils$1$1.isArrayBuffer(data) || utils$1$1.isBuffer(data) || utils$1$1.isStream(data) || utils$1$1.isFile(data) || utils$1$1.isBlob(data) || utils$1$1.isReadableStream(data)) {
        return data;
      }
      if (utils$1$1.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils$1$1.isURLSearchParams(data)) {
        headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
        return data.toString();
      }
      var isFileList;
      if (isObjectPayload) {
        if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList = utils$1$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
          var _FormData = this.env && this.env.FormData;
          return toFormData(isFileList ? {
            'files[]': data
          } : data, _FormData && new _FormData(), this.formSerializer);
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType('application/json', false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      var transitional = this.transitional || defaults$2.transitional;
      var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
      var JSONRequested = this.responseType === 'json';
      if (utils$1$1.isResponse(data) || utils$1$1.isReadableStream(data)) {
        return data;
      }
      if (data && utils$1$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e) {
          if (strictJSONParsing) {
            if (e.name === 'SyntaxError') {
              throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: 'XSRF-TOKEN',
    xsrfHeaderName: 'X-XSRF-TOKEN',
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        'Accept': 'application/json, text/plain, */*',
        'Content-Type': undefined
      }
    }
  };
  utils$1$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], function (method) {
    defaults$2.headers[method] = {};
  });
  var defaults$1$1 = defaults$2;

  // RawAxiosHeaders whose duplicates are ignored by node
  // c.f. https://nodejs.org/api/http.html#http_message_headers
  var ignoreDuplicateOf = utils$1$1.toObjectSet(['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent']);

  /**
   * Parse headers into an object
   *
   * ```
   * Date: Wed, 27 Aug 2014 08:58:49 GMT
   * Content-Type: application/json
   * Connection: keep-alive
   * Transfer-Encoding: chunked
   * ```
   *
   * @param {String} rawHeaders Headers needing to be parsed
   *
   * @returns {Object} Headers parsed into an object
   */
  var parseHeaders = function parseHeaders(rawHeaders) {
    var parsed = {};
    var key;
    var val;
    var i;
    rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
      i = line.indexOf(':');
      key = line.substring(0, i).trim().toLowerCase();
      val = line.substring(i + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === 'set-cookie') {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    });
    return parsed;
  };
  var $internals = Symbol('internals');
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils$1$1.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    var tokens = Object.create(null);
    var tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    var match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  var isValidHeaderName = function isValidHeaderName(str) {
    return /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  };
  function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
    if (utils$1$1.isFunction(filter)) {
      return filter.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils$1$1.isString(value)) return;
    if (utils$1$1.isString(filter)) {
      return value.indexOf(filter) !== -1;
    }
    if (utils$1$1.isRegExp(filter)) {
      return filter.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, function (w, char, str) {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    var accessorName = utils$1$1.toCamelCase(' ' + header);
    ['get', 'set', 'has'].forEach(function (methodName) {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function value(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  var AxiosHeaders = /*#__PURE__*/function () {
    function AxiosHeaders(headers) {
      _classCallCheck(this, AxiosHeaders);
      headers && this.set(headers);
    }
    return _createClass(AxiosHeaders, [{
      key: "set",
      value: function set(header, valueOrRewrite, rewrite) {
        var self = this;
        function setHeader(_value, _header, _rewrite) {
          var lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error('header name must be a non-empty string');
          }
          var key = utils$1$1.findKey(self, lHeader);
          if (!key || self[key] === undefined || _rewrite === true || _rewrite === undefined && self[key] !== false) {
            self[key || _header] = normalizeValue(_value);
          }
        }
        var setHeaders = function setHeaders(headers, _rewrite) {
          return utils$1$1.forEach(headers, function (_value, _header) {
            return setHeader(_value, _header, _rewrite);
          });
        };
        if (utils$1$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1$1.isHeaders(header)) {
          var _iterator2 = _createForOfIteratorHelper$3(header.entries()),
            _step2;
          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _step2$value = _slicedToArray$2(_step2.value, 2),
                key = _step2$value[0],
                value = _step2$value[1];
              setHeader(value, key, rewrite);
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
    }, {
      key: "get",
      value: function get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          var key = utils$1$1.findKey(this, header);
          if (key) {
            var value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError('parser must be boolean|regexp|function');
          }
        }
      }
    }, {
      key: "has",
      value: function has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          var key = utils$1$1.findKey(this, header);
          return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
    }, {
      key: "delete",
      value: function _delete(header, matcher) {
        var self = this;
        var deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            var key = utils$1$1.findKey(self, _header);
            if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
              delete self[key];
              deleted = true;
            }
          }
        }
        if (utils$1$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
    }, {
      key: "clear",
      value: function clear(matcher) {
        var keys = Object.keys(this);
        var i = keys.length;
        var deleted = false;
        while (i--) {
          var key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
    }, {
      key: "normalize",
      value: function normalize(format) {
        var self = this;
        var headers = {};
        utils$1$1.forEach(this, function (value, header) {
          var key = utils$1$1.findKey(headers, header);
          if (key) {
            self[key] = normalizeValue(value);
            delete self[header];
            return;
          }
          var normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self[header];
          }
          self[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
    }, {
      key: "concat",
      value: function concat() {
        var _this$constructor;
        for (var _len = arguments.length, targets = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
          targets[_key2] = arguments[_key2];
        }
        return (_this$constructor = this.constructor).concat.apply(_this$constructor, [this].concat(targets));
      }
    }, {
      key: "toJSON",
      value: function toJSON(asStrings) {
        var obj = Object.create(null);
        utils$1$1.forEach(this, function (value, header) {
          value != null && value !== false && (obj[header] = asStrings && utils$1$1.isArray(value) ? value.join(', ') : value);
        });
        return obj;
      }
    }, {
      key: Symbol.iterator,
      value: function value() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
    }, {
      key: "toString",
      value: function toString() {
        return Object.entries(this.toJSON()).map(function (_ref8) {
          var _ref9 = _slicedToArray$2(_ref8, 2),
            header = _ref9[0],
            value = _ref9[1];
          return header + ': ' + value;
        }).join('\n');
      }
    }, {
      key: Symbol.toStringTag,
      get: function get() {
        return 'AxiosHeaders';
      }
    }], [{
      key: "from",
      value: function from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
    }, {
      key: "concat",
      value: function concat(first) {
        var computed = new this(first);
        for (var _len2 = arguments.length, targets = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
          targets[_key3 - 1] = arguments[_key3];
        }
        targets.forEach(function (target) {
          return computed.set(target);
        });
        return computed;
      }
    }, {
      key: "accessor",
      value: function accessor(header) {
        var internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        var accessors = internals.accessors;
        var prototype = this.prototype;
        function defineAccessor(_header) {
          var lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    }]);
  }();
  AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

  // reserved names hotfix
  utils$1$1.reduceDescriptors(AxiosHeaders.prototype, function (_ref10, key) {
    var value = _ref10.value;
    var mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
    return {
      get: function get() {
        return value;
      },
      set: function set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils$1$1.freezeMethods(AxiosHeaders);
  var AxiosHeaders$1 = AxiosHeaders;

  /**
   * Transform the data for a request or a response
   *
   * @param {Array|Function} fns A single function or Array of functions
   * @param {?Object} response The response object
   *
   * @returns {*} The resulting transformed data
   */
  function transformData(fns, response) {
    var config = this || defaults$1$1;
    var context = response || config;
    var headers = AxiosHeaders$1.from(context.headers);
    var data = context.data;
    utils$1$1.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }

  /**
   * A `CanceledError` is an object that is thrown when an operation is canceled.
   *
   * @param {string=} message The message.
   * @param {Object=} config The config.
   * @param {Object=} request The request.
   *
   * @returns {CanceledError} The created error.
   */
  function CanceledError(message, config, request) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
    this.name = 'CanceledError';
  }
  utils$1$1.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });

  /**
   * Resolve or reject a Promise based on response status.
   *
   * @param {Function} resolve A function that resolves the promise.
   * @param {Function} reject A function that rejects the promise.
   * @param {object} response The response.
   *
   * @returns {object} The response.
   */
  function settle(resolve, reject, response) {
    var validateStatus = response.config.validateStatus;
    if (!response.status || !validateStatus || validateStatus(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError('Request failed with status code ' + response.status, [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4], response.config, response.request, response));
    }
  }
  function parseProtocol(url) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || '';
  }

  /**
   * Calculate data maxRate
   * @param {Number} [samplesCount= 10]
   * @param {Number} [min= 1000]
   * @returns {Function}
   */
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    var bytes = new Array(samplesCount);
    var timestamps = new Array(samplesCount);
    var head = 0;
    var tail = 0;
    var firstSampleTS;
    min = min !== undefined ? min : 1000;
    return function push(chunkLength) {
      var now = Date.now();
      var startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      var i = tail;
      var bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      var passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
    };
  }

  /**
   * Throttle decorator
   * @param {Function} fn
   * @param {Number} freq
   * @return {Function}
   */
  function throttle(fn, freq) {
    var timestamp = 0;
    var threshold = 1000 / freq;
    var lastArgs;
    var timer;
    var invoke = function invoke(args) {
      var now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Date.now();
      timestamp = now;
      lastArgs = null;
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
      fn.apply(null, args);
    };
    var throttled = function throttled() {
      var now = Date.now();
      var passed = now - timestamp;
      for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
        args[_key4] = arguments[_key4];
      }
      if (passed >= threshold) {
        invoke(args, now);
      } else {
        lastArgs = args;
        if (!timer) {
          timer = setTimeout(function () {
            timer = null;
            invoke(lastArgs);
          }, threshold - passed);
        }
      }
    };
    var flush = function flush() {
      return lastArgs && invoke(lastArgs);
    };
    return [throttled, flush];
  }
  var progressEventReducer = function progressEventReducer(listener, isDownloadStream) {
    var freq = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
    var bytesNotified = 0;
    var _speedometer = speedometer(50, 250);
    return throttle(function (e) {
      var loaded = e.loaded;
      var total = e.lengthComputable ? e.total : undefined;
      var progressBytes = loaded - bytesNotified;
      var rate = _speedometer(progressBytes);
      var inRange = loaded <= total;
      bytesNotified = loaded;
      var data = _defineProperty$1({
        loaded: loaded,
        total: total,
        progress: total ? loaded / total : undefined,
        bytes: progressBytes,
        rate: rate ? rate : undefined,
        estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
        event: e,
        lengthComputable: total != null
      }, isDownloadStream ? 'download' : 'upload', true);
      listener(data);
    }, freq);
  };
  var progressEventDecorator = function progressEventDecorator(total, throttled) {
    var lengthComputable = total != null;
    return [function (loaded) {
      return throttled[0]({
        lengthComputable: lengthComputable,
        total: total,
        loaded: loaded
      });
    }, throttled[1]];
  };
  var asyncDecorator = function asyncDecorator(fn) {
    return function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return utils$1$1.asap(function () {
        return fn.apply(void 0, args);
      });
    };
  };
  var isURLSameOrigin = platform.hasStandardBrowserEnv ?
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    var msie = platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover its components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;
      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = utils$1$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }() :
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }();
  var cookies = platform.hasStandardBrowserEnv ?
  // Standard browser envs support document.cookie
  {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [name + '=' + encodeURIComponent(value)];
      utils$1$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());
      utils$1$1.isString(path) && cookie.push('path=' + path);
      utils$1$1.isString(domain) && cookie.push('domain=' + domain);
      secure === true && cookie.push('secure');
      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  } :
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };

  /**
   * Determines whether the specified URL is absolute
   *
   * @param {string} url The URL to test
   *
   * @returns {boolean} True if the specified URL is absolute, otherwise false
   */
  function isAbsoluteURL(url) {
    // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
    // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
    // by any combination of letters, digits, plus, period, or hyphen.
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }

  /**
   * Creates a new URL by combining the specified URLs
   *
   * @param {string} baseURL The base URL
   * @param {string} relativeURL The relative URL
   *
   * @returns {string} The combined URL
   */
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
  }

  /**
   * Creates a new URL by combining the baseURL with the requestedURL,
   * only when the requestedURL is not already an absolute URL.
   * If the requestURL is absolute, this function returns the requestedURL untouched.
   *
   * @param {string} baseURL The base URL
   * @param {string} requestedURL Absolute or relative URL to combine
   *
   * @returns {string} The combined full path
   */
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  var headersToObject = function headersToObject(thing) {
    return thing instanceof AxiosHeaders$1 ? _objectSpread({}, thing) : thing;
  };

  /**
   * Config-specific merge-function which creates a new config-object
   * by merging two configuration objects together.
   *
   * @param {Object} config1
   * @param {Object} config2
   *
   * @returns {Object} New object resulting from merging config2 to config1
   */
  function mergeConfig(config1, config2) {
    // eslint-disable-next-line no-param-reassign
    config2 = config2 || {};
    var config = {};
    function getMergedValue(target, source, caseless) {
      if (utils$1$1.isPlainObject(target) && utils$1$1.isPlainObject(source)) {
        return utils$1$1.merge.call({
          caseless: caseless
        }, target, source);
      } else if (utils$1$1.isPlainObject(source)) {
        return utils$1$1.merge({}, source);
      } else if (utils$1$1.isArray(source)) {
        return source.slice();
      }
      return source;
    }

    // eslint-disable-next-line consistent-return
    function mergeDeepProperties(a, b, caseless) {
      if (!utils$1$1.isUndefined(b)) {
        return getMergedValue(a, b, caseless);
      } else if (!utils$1$1.isUndefined(a)) {
        return getMergedValue(undefined, a, caseless);
      }
    }

    // eslint-disable-next-line consistent-return
    function valueFromConfig2(a, b) {
      if (!utils$1$1.isUndefined(b)) {
        return getMergedValue(undefined, b);
      }
    }

    // eslint-disable-next-line consistent-return
    function defaultToConfig2(a, b) {
      if (!utils$1$1.isUndefined(b)) {
        return getMergedValue(undefined, b);
      } else if (!utils$1$1.isUndefined(a)) {
        return getMergedValue(undefined, a);
      }
    }

    // eslint-disable-next-line consistent-return
    function mergeDirectKeys(a, b, prop) {
      if (prop in config2) {
        return getMergedValue(a, b);
      } else if (prop in config1) {
        return getMergedValue(undefined, a);
      }
    }
    var mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: function headers(a, b) {
        return mergeDeepProperties(headersToObject(a), headersToObject(b), true);
      }
    };
    utils$1$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      var merge = mergeMap[prop] || mergeDeepProperties;
      var configValue = merge(config1[prop], config2[prop], prop);
      utils$1$1.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  var resolveConfig = function resolveConfig(config) {
    var newConfig = mergeConfig({}, config);
    var data = newConfig.data,
      withXSRFToken = newConfig.withXSRFToken,
      xsrfHeaderName = newConfig.xsrfHeaderName,
      xsrfCookieName = newConfig.xsrfCookieName,
      headers = newConfig.headers,
      auth = newConfig.auth;
    newConfig.headers = headers = AxiosHeaders$1.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);

    // HTTP basic authentication
    if (auth) {
      headers.set('Authorization', 'Basic ' + btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : '')));
    }
    var contentType;
    if (utils$1$1.isFormData(data)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        headers.setContentType(undefined); // Let the browser set it
      } else if ((contentType = headers.getContentType()) !== false) {
        // fix semicolon duplication issue for ReactNative FormData implementation
        var _ref11 = contentType ? contentType.split(';').map(function (token) {
            return token.trim();
          }).filter(Boolean) : [],
          _ref12 = _toArray(_ref11),
          type = _ref12[0],
          tokens = _ref12.slice(1);
        headers.setContentType([type || 'multipart/form-data'].concat(_toConsumableArray$1(tokens)).join('; '));
      }
    }

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.

    if (platform.hasStandardBrowserEnv) {
      withXSRFToken && utils$1$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
        // Add xsrf header
        var xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
        if (xsrfValue) {
          headers.set(xsrfHeaderName, xsrfValue);
        }
      }
    }
    return newConfig;
  };
  var isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';
  var xhrAdapter = isXHRAdapterSupported && function (config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      var _config = resolveConfig(config);
      var requestData = _config.data;
      var requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
      var responseType = _config.responseType,
        onUploadProgress = _config.onUploadProgress,
        onDownloadProgress = _config.onDownloadProgress;
      var onCanceled;
      var uploadThrottled, downloadThrottled;
      var flushUpload, flushDownload;
      function done() {
        flushUpload && flushUpload(); // flush events
        flushDownload && flushDownload(); // flush events

        _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
        _config.signal && _config.signal.removeEventListener('abort', onCanceled);
      }
      var request = new XMLHttpRequest();
      request.open(_config.method.toUpperCase(), _config.url, true);

      // Set the request timeout in MS
      request.timeout = _config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        // Prepare the response
        var responseHeaders = AxiosHeaders$1.from('getAllResponseHeaders' in request && request.getAllResponseHeaders());
        var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
        var response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config,
          request: request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);

        // Clean up request
        request = null;
      }
      if ('onloadend' in request) {
        // Use onloadend if available
        request.onloadend = onloadend;
      } else {
        // Listen for ready state to emulate onloadend
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }
          // readystate handler is calling before onerror or ontimeout handlers,
          // so we should call onloadend on the next 'tick'
          setTimeout(onloadend);
        };
      }

      // Handle browser request cancellation (as opposed to a manual cancellation)
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

        // Clean up request
        request = null;
      };

      // Handle low level network errors
      request.onerror = function handleError() {
        // Real errors are hidden from us by the browser
        // onerror should only fire if it's a network error
        reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

        // Clean up request
        request = null;
      };

      // Handle timeout
      request.ontimeout = function handleTimeout() {
        var timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
        var transitional = _config.transitional || transitionalDefaults;
        if (_config.timeoutErrorMessage) {
          timeoutErrorMessage = _config.timeoutErrorMessage;
        }
        reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, request));

        // Clean up request
        request = null;
      };

      // Remove Content-Type if data is undefined
      requestData === undefined && requestHeaders.setContentType(null);

      // Add headers to the request
      if ('setRequestHeader' in request) {
        utils$1$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }

      // Add withCredentials to request if needed
      if (!utils$1$1.isUndefined(_config.withCredentials)) {
        request.withCredentials = !!_config.withCredentials;
      }

      // Add responseType to request if needed
      if (responseType && responseType !== 'json') {
        request.responseType = _config.responseType;
      }

      // Handle progress if needed
      if (onDownloadProgress) {
        var _progressEventReducer = progressEventReducer(onDownloadProgress, true);
        var _progressEventReducer2 = _slicedToArray$2(_progressEventReducer, 2);
        downloadThrottled = _progressEventReducer2[0];
        flushDownload = _progressEventReducer2[1];
        request.addEventListener('progress', downloadThrottled);
      }

      // Not all browsers support upload events
      if (onUploadProgress && request.upload) {
        var _progressEventReducer3 = progressEventReducer(onUploadProgress);
        var _progressEventReducer4 = _slicedToArray$2(_progressEventReducer3, 2);
        uploadThrottled = _progressEventReducer4[0];
        flushUpload = _progressEventReducer4[1];
        request.upload.addEventListener('progress', uploadThrottled);
        request.upload.addEventListener('loadend', flushUpload);
      }
      if (_config.cancelToken || _config.signal) {
        // Handle cancellation
        // eslint-disable-next-line func-names
        onCanceled = function onCanceled(cancel) {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
        if (_config.signal) {
          _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
        }
      }
      var protocol = parseProtocol(_config.url);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
        return;
      }

      // Send the request
      request.send(requestData || null);
    });
  };
  var composeSignals = function composeSignals(signals, timeout) {
    var _signals = signals = signals ? signals.filter(Boolean) : [],
      length = _signals.length;
    if (timeout || length) {
      var controller = new AbortController();
      var aborted;
      var onabort = function onabort(reason) {
        if (!aborted) {
          aborted = true;
          unsubscribe();
          var err = reason instanceof Error ? reason : this.reason;
          controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
        }
      };
      var timer = timeout && setTimeout(function () {
        timer = null;
        onabort(new AxiosError("timeout ".concat(timeout, " of ms exceeded"), AxiosError.ETIMEDOUT));
      }, timeout);
      var unsubscribe = function unsubscribe() {
        if (signals) {
          timer && clearTimeout(timer);
          timer = null;
          signals.forEach(function (signal) {
            signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
          });
          signals = null;
        }
      };
      signals.forEach(function (signal) {
        return signal.addEventListener('abort', onabort);
      });
      var signal = controller.signal;
      signal.unsubscribe = function () {
        return utils$1$1.asap(unsubscribe);
      };
      return signal;
    }
  };
  var composeSignals$1 = composeSignals;
  var streamChunk = /*#__PURE__*/_regeneratorRuntime$1.mark(function streamChunk(chunk, chunkSize) {
    var len, pos, end;
    return _regeneratorRuntime$1.wrap(function streamChunk$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          len = chunk.byteLength;
          if (!(!chunkSize || len < chunkSize)) {
            _context.next = 5;
            break;
          }
          _context.next = 4;
          return chunk;
        case 4:
          return _context.abrupt("return");
        case 5:
          pos = 0;
        case 6:
          if (!(pos < len)) {
            _context.next = 13;
            break;
          }
          end = pos + chunkSize;
          _context.next = 10;
          return chunk.slice(pos, end);
        case 10:
          pos = end;
          _context.next = 6;
          break;
        case 13:
        case "end":
          return _context.stop();
      }
    }, streamChunk);
  });
  var readBytes = /*#__PURE__*/function () {
    var _ref = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee(iterable, chunkSize) {
      var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;
      return _regeneratorRuntime$1.wrap(function _callee$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _iteratorAbruptCompletion = false;
            _didIteratorError = false;
            _context2.prev = 2;
            _iterator = _asyncIterator(readStream(iterable));
          case 4:
            _context2.next = 6;
            return _awaitAsyncGenerator(_iterator.next());
          case 6:
            if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
              _context2.next = 12;
              break;
            }
            chunk = _step.value;
            return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(streamChunk(chunk, chunkSize))), "t0", 9);
          case 9:
            _iteratorAbruptCompletion = false;
            _context2.next = 4;
            break;
          case 12:
            _context2.next = 18;
            break;
          case 14:
            _context2.prev = 14;
            _context2.t1 = _context2["catch"](2);
            _didIteratorError = true;
            _iteratorError = _context2.t1;
          case 18:
            _context2.prev = 18;
            _context2.prev = 19;
            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {
              _context2.next = 23;
              break;
            }
            _context2.next = 23;
            return _awaitAsyncGenerator(_iterator.return());
          case 23:
            _context2.prev = 23;
            if (!_didIteratorError) {
              _context2.next = 26;
              break;
            }
            throw _iteratorError;
          case 26:
            return _context2.finish(23);
          case 27:
            return _context2.finish(18);
          case 28:
          case "end":
            return _context2.stop();
        }
      }, _callee, null, [[2, 14, 18, 28], [19,, 23, 27]]);
    }));
    return function readBytes(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();
  var readStream = /*#__PURE__*/function () {
    var _ref2 = _wrapAsyncGenerator(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee2(stream) {
      var reader, _yield$_awaitAsyncGen, done, value;
      return _regeneratorRuntime$1.wrap(function _callee2$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            if (!stream[Symbol.asyncIterator]) {
              _context3.next = 3;
              break;
            }
            return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(stream)), "t0", 2);
          case 2:
            return _context3.abrupt("return");
          case 3:
            reader = stream.getReader();
            _context3.prev = 4;
          case 5:
            _context3.next = 7;
            return _awaitAsyncGenerator(reader.read());
          case 7:
            _yield$_awaitAsyncGen = _context3.sent;
            done = _yield$_awaitAsyncGen.done;
            value = _yield$_awaitAsyncGen.value;
            if (!done) {
              _context3.next = 12;
              break;
            }
            return _context3.abrupt("break", 16);
          case 12:
            _context3.next = 14;
            return value;
          case 14:
            _context3.next = 5;
            break;
          case 16:
            _context3.prev = 16;
            _context3.next = 19;
            return _awaitAsyncGenerator(reader.cancel());
          case 19:
            return _context3.finish(16);
          case 20:
          case "end":
            return _context3.stop();
        }
      }, _callee2, null, [[4,, 16, 20]]);
    }));
    return function readStream(_x3) {
      return _ref2.apply(this, arguments);
    };
  }();
  var trackStream = function trackStream(stream, chunkSize, onProgress, onFinish) {
    var iterator = readBytes(stream, chunkSize);
    var bytes = 0;
    var done;
    var _onFinish = function _onFinish(e) {
      if (!done) {
        done = true;
        onFinish && onFinish(e);
      }
    };
    return new ReadableStream({
      pull: function pull(controller) {
        return _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee3() {
          var _yield$iterator$next, _done, value, len, loadedBytes;
          return _regeneratorRuntime$1.wrap(function _callee3$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.prev = 0;
                _context4.next = 3;
                return iterator.next();
              case 3:
                _yield$iterator$next = _context4.sent;
                _done = _yield$iterator$next.done;
                value = _yield$iterator$next.value;
                if (!_done) {
                  _context4.next = 10;
                  break;
                }
                _onFinish();
                controller.close();
                return _context4.abrupt("return");
              case 10:
                len = value.byteLength;
                if (onProgress) {
                  loadedBytes = bytes += len;
                  onProgress(loadedBytes);
                }
                controller.enqueue(new Uint8Array(value));
                _context4.next = 19;
                break;
              case 15:
                _context4.prev = 15;
                _context4.t0 = _context4["catch"](0);
                _onFinish(_context4.t0);
                throw _context4.t0;
              case 19:
              case "end":
                return _context4.stop();
            }
          }, _callee3, null, [[0, 15]]);
        }))();
      },
      cancel: function cancel(reason) {
        _onFinish(reason);
        return iterator.return();
      }
    }, {
      highWaterMark: 2
    });
  };
  var isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
  var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

  // used only inside the fetch adapter
  var encodeText = isFetchSupported && (typeof TextEncoder === 'function' ? function (encoder) {
    return function (str) {
      return encoder.encode(str);
    };
  }(new TextEncoder()) : (/*#__PURE__*/function () {
    var _ref13 = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee4(str) {
      return _regeneratorRuntime$1.wrap(function _callee4$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.t0 = Uint8Array;
            _context5.next = 3;
            return new Response(str).arrayBuffer();
          case 3:
            _context5.t1 = _context5.sent;
            return _context5.abrupt("return", new _context5.t0(_context5.t1));
          case 5:
          case "end":
            return _context5.stop();
        }
      }, _callee4);
    }));
    return function (_x4) {
      return _ref13.apply(this, arguments);
    };
  }()));
  var test$1 = function test(fn) {
    try {
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key6 = 1; _key6 < _len5; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }
      return !!fn.apply(void 0, args);
    } catch (e) {
      return false;
    }
  };
  var supportsRequestStream = isReadableStreamSupported && test$1(function () {
    var duplexAccessed = false;
    var hasContentType = new Request(platform.origin, {
      body: new ReadableStream(),
      method: 'POST',
      get duplex() {
        duplexAccessed = true;
        return 'half';
      }
    }).headers.has('Content-Type');
    return duplexAccessed && !hasContentType;
  });
  var DEFAULT_CHUNK_SIZE = 64 * 1024;
  var supportsResponseStream = isReadableStreamSupported && test$1(function () {
    return utils$1$1.isReadableStream(new Response('').body);
  });
  var resolvers = {
    stream: supportsResponseStream && function (res) {
      return res.body;
    }
  };
  isFetchSupported && function (res) {
    ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(function (type) {
      !resolvers[type] && (resolvers[type] = utils$1$1.isFunction(res[type]) ? function (res) {
        return res[type]();
      } : function (_, config) {
        throw new AxiosError("Response type '".concat(type, "' is not supported"), AxiosError.ERR_NOT_SUPPORT, config);
      });
    });
  }(new Response());
  var getBodyLength = /*#__PURE__*/function () {
    var _ref14 = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee5(body) {
      var _request;
      return _regeneratorRuntime$1.wrap(function _callee5$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            if (!(body == null)) {
              _context6.next = 2;
              break;
            }
            return _context6.abrupt("return", 0);
          case 2:
            if (!utils$1$1.isBlob(body)) {
              _context6.next = 4;
              break;
            }
            return _context6.abrupt("return", body.size);
          case 4:
            if (!utils$1$1.isSpecCompliantForm(body)) {
              _context6.next = 9;
              break;
            }
            _request = new Request(platform.origin, {
              method: 'POST',
              body: body
            });
            _context6.next = 8;
            return _request.arrayBuffer();
          case 8:
            return _context6.abrupt("return", _context6.sent.byteLength);
          case 9:
            if (!(utils$1$1.isArrayBufferView(body) || utils$1$1.isArrayBuffer(body))) {
              _context6.next = 11;
              break;
            }
            return _context6.abrupt("return", body.byteLength);
          case 11:
            if (utils$1$1.isURLSearchParams(body)) {
              body = body + '';
            }
            if (!utils$1$1.isString(body)) {
              _context6.next = 16;
              break;
            }
            _context6.next = 15;
            return encodeText(body);
          case 15:
            return _context6.abrupt("return", _context6.sent.byteLength);
          case 16:
          case "end":
            return _context6.stop();
        }
      }, _callee5);
    }));
    return function getBodyLength(_x5) {
      return _ref14.apply(this, arguments);
    };
  }();
  var resolveBodyLength = /*#__PURE__*/function () {
    var _ref15 = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee6(headers, body) {
      var length;
      return _regeneratorRuntime$1.wrap(function _callee6$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            length = utils$1$1.toFiniteNumber(headers.getContentLength());
            return _context7.abrupt("return", length == null ? getBodyLength(body) : length);
          case 2:
          case "end":
            return _context7.stop();
        }
      }, _callee6);
    }));
    return function resolveBodyLength(_x6, _x7) {
      return _ref15.apply(this, arguments);
    };
  }();
  var fetchAdapter = isFetchSupported && (/*#__PURE__*/function () {
    var _ref16 = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee7(config) {
      var _resolveConfig, url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, _resolveConfig$withCr, withCredentials, fetchOptions, composedSignal, request, unsubscribe, requestContentLength, _request, contentTypeHeader, _progressEventDecorat, _progressEventDecorat2, onProgress, flush, isCredentialsSupported, response, isStreamResponse, options, responseContentLength, _ref17, _ref18, _onProgress, _flush, responseData;
      return _regeneratorRuntime$1.wrap(function _callee7$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _resolveConfig = resolveConfig(config), url = _resolveConfig.url, method = _resolveConfig.method, data = _resolveConfig.data, signal = _resolveConfig.signal, cancelToken = _resolveConfig.cancelToken, timeout = _resolveConfig.timeout, onDownloadProgress = _resolveConfig.onDownloadProgress, onUploadProgress = _resolveConfig.onUploadProgress, responseType = _resolveConfig.responseType, headers = _resolveConfig.headers, _resolveConfig$withCr = _resolveConfig.withCredentials, withCredentials = _resolveConfig$withCr === void 0 ? 'same-origin' : _resolveConfig$withCr, fetchOptions = _resolveConfig.fetchOptions;
            responseType = responseType ? (responseType + '').toLowerCase() : 'text';
            composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
            unsubscribe = composedSignal && composedSignal.unsubscribe && function () {
              composedSignal.unsubscribe();
            };
            _context8.prev = 4;
            _context8.t0 = onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head';
            if (!_context8.t0) {
              _context8.next = 11;
              break;
            }
            _context8.next = 9;
            return resolveBodyLength(headers, data);
          case 9:
            _context8.t1 = requestContentLength = _context8.sent;
            _context8.t0 = _context8.t1 !== 0;
          case 11:
            if (!_context8.t0) {
              _context8.next = 15;
              break;
            }
            _request = new Request(url, {
              method: 'POST',
              body: data,
              duplex: "half"
            });
            if (utils$1$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              _progressEventDecorat = progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress))), _progressEventDecorat2 = _slicedToArray$2(_progressEventDecorat, 2), onProgress = _progressEventDecorat2[0], flush = _progressEventDecorat2[1];
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          case 15:
            if (!utils$1$1.isString(withCredentials)) {
              withCredentials = withCredentials ? 'include' : 'omit';
            }

            // Cloudflare Workers throws when credentials are defined
            // see https://github.com/cloudflare/workerd/issues/902
            isCredentialsSupported = "credentials" in Request.prototype;
            request = new Request(url, _objectSpread(_objectSpread({}, fetchOptions), {}, {
              signal: composedSignal,
              method: method.toUpperCase(),
              headers: headers.normalize().toJSON(),
              body: data,
              duplex: "half",
              credentials: isCredentialsSupported ? withCredentials : undefined
            }));
            _context8.next = 20;
            return fetch(request);
          case 20:
            response = _context8.sent;
            isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');
            if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
              options = {};
              ['status', 'statusText', 'headers'].forEach(function (prop) {
                options[prop] = response[prop];
              });
              responseContentLength = utils$1$1.toFiniteNumber(response.headers.get('content-length'));
              _ref17 = onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [], _ref18 = _slicedToArray$2(_ref17, 2), _onProgress = _ref18[0], _flush = _ref18[1];
              response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, _onProgress, function () {
                _flush && _flush();
                unsubscribe && unsubscribe();
              }), options);
            }
            responseType = responseType || 'text';
            _context8.next = 26;
            return resolvers[utils$1$1.findKey(resolvers, responseType) || 'text'](response, config);
          case 26:
            responseData = _context8.sent;
            !isStreamResponse && unsubscribe && unsubscribe();
            _context8.next = 30;
            return new Promise(function (resolve, reject) {
              settle(resolve, reject, {
                data: responseData,
                headers: AxiosHeaders$1.from(response.headers),
                status: response.status,
                statusText: response.statusText,
                config: config,
                request: request
              });
            });
          case 30:
            return _context8.abrupt("return", _context8.sent);
          case 33:
            _context8.prev = 33;
            _context8.t2 = _context8["catch"](4);
            unsubscribe && unsubscribe();
            if (!(_context8.t2 && _context8.t2.name === 'TypeError' && /fetch/i.test(_context8.t2.message))) {
              _context8.next = 38;
              break;
            }
            throw Object.assign(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request), {
              cause: _context8.t2.cause || _context8.t2
            });
          case 38:
            throw AxiosError.from(_context8.t2, _context8.t2 && _context8.t2.code, config, request);
          case 39:
          case "end":
            return _context8.stop();
        }
      }, _callee7, null, [[4, 33]]);
    }));
    return function (_x8) {
      return _ref16.apply(this, arguments);
    };
  }());
  var knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
  };
  utils$1$1.forEach(knownAdapters, function (fn, value) {
    if (fn) {
      try {
        Object.defineProperty(fn, 'name', {
          value: value
        });
      } catch (e) {
        // eslint-disable-next-line no-empty
      }
      Object.defineProperty(fn, 'adapterName', {
        value: value
      });
    }
  });
  var renderReason = function renderReason(reason) {
    return "- ".concat(reason);
  };
  var isResolvedHandle = function isResolvedHandle(adapter) {
    return utils$1$1.isFunction(adapter) || adapter === null || adapter === false;
  };
  var adapters = {
    getAdapter: function getAdapter(adapters) {
      adapters = utils$1$1.isArray(adapters) ? adapters : [adapters];
      var _adapters = adapters,
        length = _adapters.length;
      var nameOrAdapter;
      var adapter;
      var rejectedReasons = {};
      for (var i = 0; i < length; i++) {
        nameOrAdapter = adapters[i];
        var id = void 0;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === undefined) {
            throw new AxiosError("Unknown adapter '".concat(id, "'"));
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id || '#' + i] = adapter;
      }
      if (!adapter) {
        var reasons = Object.entries(rejectedReasons).map(function (_ref19) {
          var _ref20 = _slicedToArray$2(_ref19, 2),
            id = _ref20[0],
            state = _ref20[1];
          return "adapter ".concat(id, " ") + (state === false ? 'is not supported by the environment' : 'is not available in the build');
        });
        var s = length ? reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';
        throw new AxiosError("There is no suitable adapter to dispatch the request " + s, 'ERR_NOT_SUPPORT');
      }
      return adapter;
    },
    adapters: knownAdapters
  };

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   *
   * @param {Object} config The config that is to be used for the request
   *
   * @returns {void}
   */
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }

  /**
   * Dispatch a request to the server using the configured adapter.
   *
   * @param {object} config The config that is to be used for the request
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);

    // Transform request data
    config.data = transformData.call(config, config.transformRequest);
    if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
      config.headers.setContentType('application/x-www-form-urlencoded', false);
    }
    var adapter = adapters.getAdapter(config.adapter || defaults$1$1.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);

      // Transform response data
      response.data = transformData.call(config, config.transformResponse, response);
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);

        // Transform response data
        if (reason && reason.response) {
          reason.response.data = transformData.call(config, config.transformResponse, reason.response);
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  var VERSION = "1.7.7";
  var validators$1 = {};

  // eslint-disable-next-line func-names
  ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {
    validators$1[type] = function validator(thing) {
      return _typeof$3(thing) === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
    };
  });
  var deprecatedWarnings = {};

  /**
   * Transitional option validator
   *
   * @param {function|boolean?} validator - set to false if the transitional option has been removed
   * @param {string?} version - deprecated version / removed since version
   * @param {string?} message - some message with additional info
   *
   * @returns {function}
   */
  validators$1.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
      return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
    }

    // eslint-disable-next-line func-names
    return function (value, opt, opts) {
      if (validator === false) {
        throw new AxiosError(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')), AxiosError.ERR_DEPRECATED);
      }
      if (version && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        // eslint-disable-next-line no-console
        console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
      }
      return validator ? validator(value, opt, opts) : true;
    };
  };

  /**
   * Assert object's properties type
   *
   * @param {object} options
   * @param {object} schema
   * @param {boolean?} allowUnknown
   *
   * @returns {object}
   */

  function assertOptions(options, schema, allowUnknown) {
    if (_typeof$3(options) !== 'object') {
      throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
    }
    var keys = Object.keys(options);
    var i = keys.length;
    while (i-- > 0) {
      var opt = keys[i];
      var _validator = schema[opt];
      if (_validator) {
        var value = options[opt];
        var result = value === undefined || _validator(value, opt, options);
        if (result !== true) {
          throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  var validator = {
    assertOptions: assertOptions,
    validators: validators$1
  };
  var validators = validator.validators;

  /**
   * Create a new instance of Axios
   *
   * @param {Object} instanceConfig The default config for the instance
   *
   * @return {Axios} A new instance of Axios
   */
  var Axios = /*#__PURE__*/function () {
    function Axios(instanceConfig) {
      _classCallCheck(this, Axios);
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    return _createClass(Axios, [{
      key: "request",
      value: (function () {
        var _request2 = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee8(configOrUrl, config) {
          var dummy, stack;
          return _regeneratorRuntime$1.wrap(function _callee8$(_context9) {
            while (1) switch (_context9.prev = _context9.next) {
              case 0:
                _context9.prev = 0;
                _context9.next = 3;
                return this._request(configOrUrl, config);
              case 3:
                return _context9.abrupt("return", _context9.sent);
              case 6:
                _context9.prev = 6;
                _context9.t0 = _context9["catch"](0);
                if (_context9.t0 instanceof Error) {
                  Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();

                  // slice off the Error: ... line
                  stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
                  try {
                    if (!_context9.t0.stack) {
                      _context9.t0.stack = stack;
                      // match without the 2 top stack lines
                    } else if (stack && !String(_context9.t0.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
                      _context9.t0.stack += '\n' + stack;
                    }
                  } catch (e) {
                    // ignore the case where "stack" is an un-writable property
                  }
                }
                throw _context9.t0;
              case 10:
              case "end":
                return _context9.stop();
            }
          }, _callee8, this, [[0, 6]]);
        }));
        function request(_x9, _x10) {
          return _request2.apply(this, arguments);
        }
        return request;
      }())
    }, {
      key: "_request",
      value: function _request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/
        // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === 'string') {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        var _config2 = config,
          transitional = _config2.transitional,
          paramsSerializer = _config2.paramsSerializer,
          headers = _config2.headers;
        if (transitional !== undefined) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }

        // Set config.method
        config.method = (config.method || this.defaults.method || 'get').toLowerCase();

        // Flatten headers
        var contextHeaders = headers && utils$1$1.merge(headers.common, headers[config.method]);
        headers && utils$1$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function (method) {
          delete headers[method];
        });
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

        // filter out skipped interceptors
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        var i = 0;
        var len;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest.bind(this), undefined];
          chain.unshift.apply(chain, requestInterceptorChain);
          chain.push.apply(chain, responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        var newConfig = config;
        i = 0;
        while (i < len) {
          var onFulfilled = requestInterceptorChain[i++];
          var onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
    }, {
      key: "getUri",
      value: function getUri(config) {
        config = mergeConfig(this.defaults, config);
        var fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    }]);
  }(); // Provide aliases for supported request methods
  utils$1$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
    /*eslint func-names:0*/
    Axios.prototype[method] = function (url, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        url: url,
        data: (config || {}).data
      }));
    };
  });
  utils$1$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
    /*eslint func-names:0*/

    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          headers: isForm ? {
            'Content-Type': 'multipart/form-data'
          } : {},
          url: url,
          data: data
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
  });
  var Axios$1 = Axios;

  /**
   * A `CancelToken` is an object that can be used to request cancellation of an operation.
   *
   * @param {Function} executor The executor function.
   *
   * @returns {CancelToken}
   */
  var CancelToken = /*#__PURE__*/function () {
    function CancelToken(executor) {
      _classCallCheck(this, CancelToken);
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;

      // eslint-disable-next-line func-names
      this.promise.then(function (cancel) {
        if (!token._listeners) return;
        var i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });

      // eslint-disable-next-line func-names
      this.promise.then = function (onfulfilled) {
        var _resolve;
        // eslint-disable-next-line func-names
        var promise = new Promise(function (resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }
        token.reason = new CanceledError(message, config, request);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    return _createClass(CancelToken, [{
      key: "throwIfRequested",
      value: function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }

      /**
       * Subscribe to the cancel signal
       */
    }, {
      key: "subscribe",
      value: function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }

      /**
       * Unsubscribe from the cancel signal
       */
    }, {
      key: "unsubscribe",
      value: function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
    }, {
      key: "toAbortSignal",
      value: function toAbortSignal() {
        var _this = this;
        var controller = new AbortController();
        var abort = function abort(err) {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = function () {
          return _this.unsubscribe(abort);
        };
        return controller.signal;
      }

      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
    }], [{
      key: "source",
      value: function source() {
        var cancel;
        var token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token: token,
          cancel: cancel
        };
      }
    }]);
  }();
  var CancelToken$1 = CancelToken;

  /**
   * Syntactic sugar for invoking a function and expanding an array for arguments.
   *
   * Common use case would be to use `Function.prototype.apply`.
   *
   *  ```js
   *  function f(x, y, z) {}
   *  var args = [1, 2, 3];
   *  f.apply(null, args);
   *  ```
   *
   * With `spread` this example can be re-written.
   *
   *  ```js
   *  spread(function(x, y, z) {})([1, 2, 3]);
   *  ```
   *
   * @param {Function} callback
   *
   * @returns {Function}
   */
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }

  /**
   * Determines whether the payload is an error thrown by Axios
   *
   * @param {*} payload The value to test
   *
   * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
   */
  function isAxiosError(payload) {
    return utils$1$1.isObject(payload) && payload.isAxiosError === true;
  }
  var HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(function (_ref21) {
    var _ref22 = _slicedToArray$2(_ref21, 2),
      key = _ref22[0],
      value = _ref22[1];
    HttpStatusCode[value] = key;
  });
  var HttpStatusCode$1 = HttpStatusCode;

  /**
   * Create an instance of Axios
   *
   * @param {Object} defaultConfig The default config for the instance
   *
   * @returns {Axios} A new instance of Axios
   */
  function createInstance(defaultConfig) {
    var context = new Axios$1(defaultConfig);
    var instance = bind$2(Axios$1.prototype.request, context);

    // Copy axios.prototype to instance
    utils$1$1.extend(instance, Axios$1.prototype, context, {
      allOwnKeys: true
    });

    // Copy context to instance
    utils$1$1.extend(instance, context, null, {
      allOwnKeys: true
    });

    // Factory for creating new instances
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }

  // Create the default instance to be exported
  var axios = createInstance(defaults$1$1);

  // Expose Axios class to allow class inheritance
  axios.Axios = Axios$1;

  // Expose Cancel & CancelToken
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;

  // Expose AxiosError class
  axios.AxiosError = AxiosError;

  // alias for CanceledError for backward compatibility
  axios.Cancel = axios.CanceledError;

  // Expose all/spread
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;

  // Expose isAxiosError
  axios.isAxiosError = isAxiosError;

  // Expose mergeConfig
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = function (thing) {
    return formDataToJSON(utils$1$1.isHTMLForm(thing) ? new FormData(thing) : thing);
  };
  axios.getAdapter = adapters.getAdapter;
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  var axios_1 = axios;
  var axios$1 = /*@__PURE__*/getDefaultExportFromCjs(axios_1);

  var fastCopy$1 = {exports: {}};

  (function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    })(this, function () {

      var toStringFunction = Function.prototype.toString;
      var create = Object.create,
        defineProperty = Object.defineProperty,
        getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
        getOwnPropertyNames = Object.getOwnPropertyNames,
        getOwnPropertySymbols = Object.getOwnPropertySymbols,
        getPrototypeOf$1 = Object.getPrototypeOf;
      var _a = Object.prototype,
        hasOwnProperty = _a.hasOwnProperty,
        propertyIsEnumerable = _a.propertyIsEnumerable;
      var SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';
      var WEAK_MAP = typeof WeakMap === 'function';
      /**
       * @function createCache
       *
       * @description
       * get a new cache object to prevent circular references
       *
       * @returns the new cache object
       */
      var createCache = function () {
        if (WEAK_MAP) {
          return function () {
            return new WeakMap();
          };
        }
        var Cache = /** @class */function () {
          function Cache() {
            this._keys = [];
            this._values = [];
          }
          Cache.prototype.has = function (key) {
            return !!~this._keys.indexOf(key);
          };
          Cache.prototype.get = function (key) {
            return this._values[this._keys.indexOf(key)];
          };
          Cache.prototype.set = function (key, value) {
            this._keys.push(key);
            this._values.push(value);
          };
          return Cache;
        }();
        return function () {
          return new Cache();
        };
      }();
      /**
       * @function getCleanClone
       *
       * @description
       * get an empty version of the object with the same prototype it has
       *
       * @param object the object to build a clean clone from
       * @param realm the realm the object resides in
       * @returns the empty cloned object
       */
      var getCleanClone = function getCleanClone(object, realm) {
        var prototype = object.__proto__ || getPrototypeOf$1(object);
        if (!prototype) {
          return create(null);
        }
        var Constructor = prototype.constructor;
        if (Constructor === realm.Object) {
          return prototype === realm.Object.prototype ? {} : create(prototype);
        }
        if (~toStringFunction.call(Constructor).indexOf('[native code]')) {
          try {
            return new Constructor();
          } catch (_a) {}
        }
        return create(prototype);
      };
      /**
       * @function getObjectCloneLoose
       *
       * @description
       * get a copy of the object based on loose rules, meaning all enumerable keys
       * and symbols are copied, but property descriptors are not considered
       *
       * @param object the object to clone
       * @param realm the realm the object resides in
       * @param handleCopy the function that handles copying the object
       * @returns the copied object
       */
      var getObjectCloneLoose = function getObjectCloneLoose(object, realm, handleCopy, cache) {
        var clone = getCleanClone(object, realm);
        // set in the cache immediately to be able to reuse the object recursively
        cache.set(object, clone);
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            clone[key] = handleCopy(object[key], cache);
          }
        }
        if (SYMBOL_PROPERTIES) {
          var symbols = getOwnPropertySymbols(object);
          for (var index = 0, length_1 = symbols.length, symbol = void 0; index < length_1; ++index) {
            symbol = symbols[index];
            if (propertyIsEnumerable.call(object, symbol)) {
              clone[symbol] = handleCopy(object[symbol], cache);
            }
          }
        }
        return clone;
      };
      /**
       * @function getObjectCloneStrict
       *
       * @description
       * get a copy of the object based on strict rules, meaning all keys and symbols
       * are copied based on the original property descriptors
       *
       * @param object the object to clone
       * @param realm the realm the object resides in
       * @param handleCopy the function that handles copying the object
       * @returns the copied object
       */
      var getObjectCloneStrict = function getObjectCloneStrict(object, realm, handleCopy, cache) {
        var clone = getCleanClone(object, realm);
        // set in the cache immediately to be able to reuse the object recursively
        cache.set(object, clone);
        var properties = SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);
        for (var index = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index < length_2; ++index) {
          property = properties[index];
          if (property !== 'callee' && property !== 'caller') {
            descriptor = getOwnPropertyDescriptor(object, property);
            if (descriptor) {
              // Only clone the value if actually a value, not a getter / setter.
              if (!descriptor.get && !descriptor.set) {
                descriptor.value = handleCopy(object[property], cache);
              }
              try {
                defineProperty(clone, property, descriptor);
              } catch (error) {
                // Tee above can fail on node in edge cases, so fall back to the loose assignment.
                clone[property] = descriptor.value;
              }
            } else {
              // In extra edge cases where the property descriptor cannot be retrived, fall back to
              // the loose assignment.
              clone[property] = handleCopy(object[property], cache);
            }
          }
        }
        return clone;
      };
      /**
       * @function getRegExpFlags
       *
       * @description
       * get the flags to apply to the copied regexp
       *
       * @param regExp the regexp to get the flags of
       * @returns the flags for the regexp
       */
      var getRegExpFlags = function getRegExpFlags(regExp) {
        var flags = '';
        if (regExp.global) {
          flags += 'g';
        }
        if (regExp.ignoreCase) {
          flags += 'i';
        }
        if (regExp.multiline) {
          flags += 'm';
        }
        if (regExp.unicode) {
          flags += 'u';
        }
        if (regExp.sticky) {
          flags += 'y';
        }
        return flags;
      };

      // utils
      var isArray = Array.isArray;
      var getPrototypeOf = Object.getPrototypeOf;
      var GLOBAL_THIS = function () {
        if (typeof globalThis !== 'undefined') {
          return globalThis;
        }
        if (typeof self !== 'undefined') {
          return self;
        }
        if (typeof window !== 'undefined') {
          return window;
        }
        if (typeof global !== 'undefined') {
          return global;
        }
        if (console && console.error) {
          console.error('Unable to locate global object, returning "this".');
        }
        return this;
      }();
      /**
       * @function copy
       *
       * @description
       * copy an value deeply as much as possible
       *
       * If `strict` is applied, then all properties (including non-enumerable ones)
       * are copied with their original property descriptors on both objects and arrays.
       *
       * The value is compared to the global constructors in the `realm` provided,
       * and the native constructor is always used to ensure that extensions of native
       * objects (allows in ES2015+) are maintained.
       *
       * @param value the value to copy
       * @param [options] the options for copying with
       * @param [options.isStrict] should the copy be strict
       * @param [options.realm] the realm (this) value the value is copied from
       * @returns the copied value
       */
      function copy(value, options) {
        // manually coalesced instead of default parameters for performance
        var isStrict = !!(options && options.isStrict);
        var realm = options && options.realm || GLOBAL_THIS;
        var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;
        /**
         * @function handleCopy
         *
         * @description
         * copy the value recursively based on its type
         *
         * @param value the value to copy
         * @returns the copied value
         */
        var _handleCopy = function handleCopy(value, cache) {
          if (!value || _typeof$3(value) !== 'object') {
            return value;
          }
          if (cache.has(value)) {
            return cache.get(value);
          }
          var prototype = value.__proto__ || getPrototypeOf(value);
          var Constructor = prototype && prototype.constructor;
          // plain objects
          if (!Constructor || Constructor === realm.Object) {
            return getObjectClone(value, realm, _handleCopy, cache);
          }
          var clone;
          // arrays
          if (isArray(value)) {
            // if strict, include non-standard properties
            if (isStrict) {
              return getObjectCloneStrict(value, realm, _handleCopy, cache);
            }
            clone = new Constructor();
            cache.set(value, clone);
            for (var index = 0, length_1 = value.length; index < length_1; ++index) {
              clone[index] = _handleCopy(value[index], cache);
            }
            return clone;
          }
          // dates
          if (value instanceof realm.Date) {
            return new Constructor(value.getTime());
          }
          // regexps
          if (value instanceof realm.RegExp) {
            clone = new Constructor(value.source, value.flags || getRegExpFlags(value));
            clone.lastIndex = value.lastIndex;
            return clone;
          }
          // maps
          if (realm.Map && value instanceof realm.Map) {
            clone = new Constructor();
            cache.set(value, clone);
            value.forEach(function (value, key) {
              clone.set(key, _handleCopy(value, cache));
            });
            return clone;
          }
          // sets
          if (realm.Set && value instanceof realm.Set) {
            clone = new Constructor();
            cache.set(value, clone);
            value.forEach(function (value) {
              clone.add(_handleCopy(value, cache));
            });
            return clone;
          }
          // blobs
          if (realm.Blob && value instanceof realm.Blob) {
            return value.slice(0, value.size, value.type);
          }
          // buffers (node-only)
          if (realm.Buffer && realm.Buffer.isBuffer(value)) {
            clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(value.length) : new Constructor(value.length);
            cache.set(value, clone);
            value.copy(clone);
            return clone;
          }
          // arraybuffers / dataviews
          if (realm.ArrayBuffer) {
            // dataviews
            if (realm.ArrayBuffer.isView(value)) {
              clone = new Constructor(value.buffer.slice(0));
              cache.set(value, clone);
              return clone;
            }
            // arraybuffers
            if (value instanceof realm.ArrayBuffer) {
              clone = value.slice(0);
              cache.set(value, clone);
              return clone;
            }
          }
          // if the value cannot / should not be cloned, don't
          if (
          // promise-like
          typeof value.then === 'function' ||
          // errors
          value instanceof Error ||
          // weakmaps
          realm.WeakMap && value instanceof realm.WeakMap ||
          // weaksets
          realm.WeakSet && value instanceof realm.WeakSet) {
            return value;
          }
          // assume anything left is a custom constructor
          return getObjectClone(value, realm, _handleCopy, cache);
        };
        return _handleCopy(value, createCache());
      }
      // Adding reference to allow usage in CommonJS libraries compiled using TSC, which
      // expects there to be a default property on the exported value. See
      // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.
      copy.default = copy;
      /**
       * @function strictCopy
       *
       * @description
       * copy the value with `strict` option pre-applied
       *
       * @param value the value to copy
       * @param [options] the options for copying with
       * @param [options.realm] the realm (this) value the value is copied from
       * @returns the copied value
       */
      copy.strict = function strictCopy(value, options) {
        return copy(value, {
          isStrict: true,
          realm: options ? options.realm : void 0
        });
      };
      return copy;
    });
  })(fastCopy$1);
  var fastCopyExports$1 = fastCopy$1.exports;
  var copy$1 = /*@__PURE__*/getDefaultExportFromCjs(fastCopyExports$1);

  /** @type {import('.')} */
  var esErrors = Error;

  /** @type {import('./eval')} */
  var _eval = EvalError;

  /** @type {import('./range')} */
  var range = RangeError;

  /** @type {import('./ref')} */
  var ref = ReferenceError;

  /** @type {import('./syntax')} */
  var syntax = SyntaxError;

  /** @type {import('./type')} */
  var type = TypeError;

  /** @type {import('./uri')} */
  var uri = URIError;

  /* eslint complexity: [2, 18], max-statements: [2, 33] */
  var shams = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
      return false;
    }
    if (_typeof$3(Symbol.iterator) === 'symbol') {
      return true;
    }
    var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
      return false;
    }

    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }

    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };

  var origSymbol = typeof Symbol !== 'undefined' && Symbol;
  var hasSymbolSham = shams;
  var hasSymbols$1 = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
      return false;
    }
    if (typeof Symbol !== 'function') {
      return false;
    }
    if (_typeof$3(origSymbol('foo')) !== 'symbol') {
      return false;
    }
    if (_typeof$3(Symbol('bar')) !== 'symbol') {
      return false;
    }
    return hasSymbolSham();
  };

  var test = {
    __proto__: null,
    foo: {}
  };
  var $Object = Object;

  /** @type {import('.')} */
  var hasProto$1 = function hasProto() {
    // @ts-expect-error: TS errors on an inherited property for some reason
    return {
      __proto__: test
    }.foo === test.foo && !(test instanceof $Object);
  };

  /* eslint no-invalid-this: 1 */

  var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
  var toStr$1 = Object.prototype.toString;
  var max = Math.max;
  var funcType = '[object Function]';
  var concatty = function concatty(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function joiny(arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  var implementation$1 = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr$1.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function binder() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
      var Empty = function Empty() {};
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };

  var implementation = implementation$1;
  var functionBind = Function.prototype.bind || implementation;

  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind$1 = functionBind;

  /** @type {import('.')} */
  var hasown = bind$1.call(call, $hasOwn);

  var undefined$1;
  var $Error = esErrors;
  var $EvalError = _eval;
  var $RangeError = range;
  var $ReferenceError = ref;
  var $SyntaxError$1 = syntax;
  var $TypeError$3 = type;
  var $URIError = uri;
  var $Function = Function;

  // eslint-disable-next-line consistent-return
  var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
  };
  var $gOPD$1 = Object.getOwnPropertyDescriptor;
  if ($gOPD$1) {
    try {
      $gOPD$1({}, '');
    } catch (e) {
      $gOPD$1 = null; // this is IE 8, which has a broken gOPD
    }
  }
  var throwTypeError = function throwTypeError() {
    throw new $TypeError$3();
  };
  var ThrowTypeError = $gOPD$1 ? function () {
    try {
      // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
      arguments.callee; // IE 8 does not throw here
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
        return $gOPD$1(arguments, 'callee').get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = hasSymbols$1();
  var hasProto = hasProto$1();
  var getProto = Object.getPrototypeOf || (hasProto ? function (x) {
    return x.__proto__;
  } // eslint-disable-line no-proto
  : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    '%AsyncFromSyncIteratorPrototype%': undefined$1,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    // eslint-disable-line no-eval
    '%EvalError%': $EvalError,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    '%JSON%': (typeof JSON === "undefined" ? "undefined" : _typeof$3(JSON)) === 'object' ? JSON : undefined$1,
    '%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': Object,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
    '%Symbol%': hasSymbols ? Symbol : undefined$1,
    '%SyntaxError%': $SyntaxError$1,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError$3,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
  };
  if (getProto) {
    try {
      null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
      // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
      var errorProto = getProto(getProto(e));
      INTRINSICS['%Error.prototype%'] = errorProto;
    }
  }
  var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
      value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
      value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
      value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
      var fn = doEval('%AsyncGeneratorFunction%');
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === '%AsyncIteratorPrototype%') {
      var gen = doEval('%AsyncGenerator%');
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
    '%ArrayPrototype%': ['Array', 'prototype'],
    '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
    '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
    '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
    '%ArrayProto_values%': ['Array', 'prototype', 'values'],
    '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
    '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
    '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
    '%BooleanPrototype%': ['Boolean', 'prototype'],
    '%DataViewPrototype%': ['DataView', 'prototype'],
    '%DatePrototype%': ['Date', 'prototype'],
    '%ErrorPrototype%': ['Error', 'prototype'],
    '%EvalErrorPrototype%': ['EvalError', 'prototype'],
    '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
    '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
    '%FunctionPrototype%': ['Function', 'prototype'],
    '%Generator%': ['GeneratorFunction', 'prototype'],
    '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
    '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
    '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
    '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
    '%JSONParse%': ['JSON', 'parse'],
    '%JSONStringify%': ['JSON', 'stringify'],
    '%MapPrototype%': ['Map', 'prototype'],
    '%NumberPrototype%': ['Number', 'prototype'],
    '%ObjectPrototype%': ['Object', 'prototype'],
    '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
    '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
    '%PromisePrototype%': ['Promise', 'prototype'],
    '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
    '%Promise_all%': ['Promise', 'all'],
    '%Promise_reject%': ['Promise', 'reject'],
    '%Promise_resolve%': ['Promise', 'resolve'],
    '%RangeErrorPrototype%': ['RangeError', 'prototype'],
    '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
    '%RegExpPrototype%': ['RegExp', 'prototype'],
    '%SetPrototype%': ['Set', 'prototype'],
    '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
    '%StringPrototype%': ['String', 'prototype'],
    '%SymbolPrototype%': ['Symbol', 'prototype'],
    '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
    '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
    '%TypeErrorPrototype%': ['TypeError', 'prototype'],
    '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
    '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
    '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
    '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
    '%URIErrorPrototype%': ['URIError', 'prototype'],
    '%WeakMapPrototype%': ['WeakMap', 'prototype'],
    '%WeakSetPrototype%': ['WeakSet', 'prototype']
  };
  var bind = functionBind;
  var hasOwn$1 = hasown;
  var $concat$1 = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace$1 = bind.call(Function.call, String.prototype.replace);
  var $strSlice = bind.call(Function.call, String.prototype.slice);
  var $exec = bind.call(Function.call, RegExp.prototype.exec);

  /* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
  var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
      throw new $SyntaxError$1('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
      throw new $SyntaxError$1('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace$1(string, rePropName, function (match, number, quote, subString) {
      result[result.length] = quote ? $replace$1(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
  };
  /* end adaptation */

  var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn$1(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn$1(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === 'undefined' && !allowMissing) {
        throw new $TypeError$3('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
      }
      return {
        alias: alias,
        name: intrinsicName,
        value: value
      };
    }
    throw new $SyntaxError$1('intrinsic ' + name + ' does not exist!');
  };
  var getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
      throw new $TypeError$3('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
      throw new $TypeError$3('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError$1('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat$1([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
        throw new $SyntaxError$1('property names with quotes must have matching quotes');
      }
      if (part === 'constructor' || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += '.' + part;
      intrinsicRealName = '%' + intrinsicBaseName + '%';
      if (hasOwn$1(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError$3('base intrinsic for ' + name + ' exists, but the property is not available.');
          }
          return void undefined$1;
        }
        if ($gOPD$1 && i + 1 >= parts.length) {
          var desc = $gOPD$1(value, part);
          isOwn = !!desc;

          // By convention, when a data property is converted to an accessor
          // property to emulate a data property that does not suffer from
          // the override mistake, that accessor's getter is marked with
          // an `originalValue` property. Here, when we detect this, we
          // uphold the illusion by pretending to see that original data
          // property, i.e., returning the value rather than the getter
          // itself.
          if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn$1(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };

  var callBind$1 = {exports: {}};

  var esDefineProperty;
  var hasRequiredEsDefineProperty;
  function requireEsDefineProperty() {
    if (hasRequiredEsDefineProperty) return esDefineProperty;
    hasRequiredEsDefineProperty = 1;
    var GetIntrinsic = getIntrinsic;

    /** @type {import('.')} */
    var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, 'a', {
          value: 1
        });
      } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
      }
    }
    esDefineProperty = $defineProperty;
    return esDefineProperty;
  }

  var GetIntrinsic$3 = getIntrinsic;
  var $gOPD = GetIntrinsic$3('%Object.getOwnPropertyDescriptor%', true);
  if ($gOPD) {
    try {
      $gOPD([], 'length');
    } catch (e) {
      // IE 8 has a broken gOPD
      $gOPD = null;
    }
  }
  var gopd$1 = $gOPD;

  var $defineProperty$1 = requireEsDefineProperty();
  var $SyntaxError = syntax;
  var $TypeError$2 = type;
  var gopd = gopd$1;

  /** @type {import('.')} */
  var defineDataProperty = function defineDataProperty(obj, property, value) {
    if (!obj || _typeof$3(obj) !== 'object' && typeof obj !== 'function') {
      throw new $TypeError$2('`obj` must be an object or a function`');
    }
    if (typeof property !== 'string' && _typeof$3(property) !== 'symbol') {
      throw new $TypeError$2('`property` must be a string or a symbol`');
    }
    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
      throw new $TypeError$2('`nonEnumerable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
      throw new $TypeError$2('`nonWritable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
      throw new $TypeError$2('`nonConfigurable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
      throw new $TypeError$2('`loose`, if provided, must be a boolean');
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;

    /* @type {false | TypedPropertyDescriptor<unknown>} */
    var desc = !!gopd && gopd(obj, property);
    if ($defineProperty$1) {
      $defineProperty$1(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value: value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
      obj[property] = value; // eslint-disable-line no-param-reassign
    } else {
      throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
    }
  };

  var $defineProperty = requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    // node v0.6 has a bug where array lengths can be Set but not Defined
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], 'length', {
        value: 1
      }).length !== 1;
    } catch (e) {
      // In Firefox 4-22, defining length on an array throws an exception.
      return true;
    }
  };
  var hasPropertyDescriptors_1 = hasPropertyDescriptors;

  var GetIntrinsic$2 = getIntrinsic;
  var define = defineDataProperty;
  var hasDescriptors = hasPropertyDescriptors_1();
  var gOPD = gopd$1;
  var $TypeError$1 = type;
  var $floor$1 = GetIntrinsic$2('%Math.floor%');

  /** @type {import('.')} */
  var setFunctionLength = function setFunctionLength(fn, length) {
    if (typeof fn !== 'function') {
      throw new $TypeError$1('`fn` is not a function');
    }
    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor$1(length) !== length) {
      throw new $TypeError$1('`length` must be a positive 32-bit integer');
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ('length' in fn && gOPD) {
      var desc = gOPD(fn, 'length');
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(/** @type {Parameters<define>[0]} */fn, 'length', length, true, true);
      } else {
        define(/** @type {Parameters<define>[0]} */fn, 'length', length);
      }
    }
    return fn;
  };

  (function (module) {

    var bind = functionBind;
    var GetIntrinsic = getIntrinsic;
    var setFunctionLength$1 = setFunctionLength;
    var $TypeError = type;
    var $apply = GetIntrinsic('%Function.prototype.apply%');
    var $call = GetIntrinsic('%Function.prototype.call%');
    var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
    var $defineProperty = requireEsDefineProperty();
    var $max = GetIntrinsic('%Math.max%');
    module.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== 'function') {
        throw new $TypeError('a function is required');
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength$1(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
    };
    var applyBind = function applyBind() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module.exports, 'apply', {
        value: applyBind
      });
    } else {
      module.exports.apply = applyBind;
    }
  })(callBind$1);
  var callBindExports = callBind$1.exports;

  var GetIntrinsic$1 = getIntrinsic;
  var callBind = callBindExports;
  var $indexOf = callBind(GetIntrinsic$1('String.prototype.indexOf'));
  var callBound$1 = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic$1(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
      return callBind(intrinsic);
    }
    return intrinsic;
  };

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: _nodeResolve_empty
  });

  var require$$0 = /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(_nodeResolve_empty$1);

  var hasMap = typeof Map === 'function' && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === 'function' && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString$2 = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === 'function' && _typeof$3(Symbol.iterator) === 'symbol' ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === 'function' && _typeof$3(Symbol.iterator) === 'object';
  // ie, `has-tostringtag/shams
  var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (_typeof$3(Symbol.toStringTag) === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
  ? function (O) {
    return O.__proto__; // eslint-disable-line no-proto
  } : null);
  function addNumericSeparator(num, str) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === 'number') {
      var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
      }
    }
    return $replace.call(str, sepRegex, '$&_');
  }
  var utilInspect = require$$0;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  var objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has$3(opts, 'quoteStyle') && opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double') {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has$3(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has$3(opts, 'customInspect') ? opts.customInspect : true;
    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
      throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
    }
    if (has$3(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has$3(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === 'undefined') {
      return 'undefined';
    }
    if (obj === null) {
      return 'null';
    }
    if (typeof obj === 'boolean') {
      return obj ? 'true' : 'false';
    }
    if (typeof obj === 'string') {
      return inspectString(obj, opts);
    }
    if (typeof obj === 'number') {
      if (obj === 0) {
        return Infinity / obj > 0 ? '0' : '-0';
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === 'bigint') {
      var bigIntStr = String(obj) + 'n';
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;
    if (typeof depth === 'undefined') {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && _typeof$3(obj) === 'object') {
      return isArray$4(obj) ? '[Array]' : '[Object]';
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === 'undefined') {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return '[Circular]';
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has$3(opts, 'quoteStyle')) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === 'function' && !isRegExp$1(obj)) {
      // in older engines, regexes are callable
      var name = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
      return _typeof$3(obj) === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s = '<' + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
      }
      s += '>';
      if (obj.childNodes && obj.childNodes.length) {
        s += '...';
      }
      s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
      return s;
    }
    if (isArray$4(obj)) {
      if (obj.length === 0) {
        return '[]';
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return '[' + indentedJoin(xs, indent) + ']';
      }
      return '[ ' + $join.call(xs, ', ') + ' ]';
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
        return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
      }
      if (parts.length === 0) {
        return '[' + String(obj) + ']';
      }
      return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
    }
    if (_typeof$3(obj) === 'object' && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
        return utilInspect(obj, {
          depth: maxDepth - depth
        });
      } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function (value, key) {
          mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
        });
      }
      return collectionOf('Map', mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function (value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf('Set', setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf('WeakMap');
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf('WeakSet');
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf('WeakRef');
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString$2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    // note: in IE 8, sometimes `global !== window` but both are the prototypes of each other
    /* eslint-env browser */
    if (typeof window !== 'undefined' && obj === window) {
      return '{ [object Window] }';
    }
    if (typeof globalThis !== 'undefined' && obj === globalThis || typeof global !== 'undefined' && obj === global) {
      return '{ [object globalThis] }';
    }
    if (!isDate(obj) && !isRegExp$1(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? '' : 'null prototype';
      var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
      var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
      var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');
      if (ys.length === 0) {
        return tag + '{}';
      }
      if (indent) {
        return tag + '{' + indentedJoin(ys, indent) + '}';
      }
      return tag + '{ ' + $join.call(ys, ', ') + ' }';
    }
    return String(obj);
  };
  function wrapQuotes(s, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
    return quoteChar + s + quoteChar;
  }
  function quote(s) {
    return $replace.call(String(s), /"/g, '&quot;');
  }
  function isArray$4(obj) {
    return toStr(obj) === '[object Array]' && (!toStringTag || !(_typeof$3(obj) === 'object' && toStringTag in obj));
  }
  function isDate(obj) {
    return toStr(obj) === '[object Date]' && (!toStringTag || !(_typeof$3(obj) === 'object' && toStringTag in obj));
  }
  function isRegExp$1(obj) {
    return toStr(obj) === '[object RegExp]' && (!toStringTag || !(_typeof$3(obj) === 'object' && toStringTag in obj));
  }
  function isError(obj) {
    return toStr(obj) === '[object Error]' && (!toStringTag || !(_typeof$3(obj) === 'object' && toStringTag in obj));
  }
  function isString$2(obj) {
    return toStr(obj) === '[object String]' && (!toStringTag || !(_typeof$3(obj) === 'object' && toStringTag in obj));
  }
  function isNumber(obj) {
    return toStr(obj) === '[object Number]' && (!toStringTag || !(_typeof$3(obj) === 'object' && toStringTag in obj));
  }
  function isBoolean(obj) {
    return toStr(obj) === '[object Boolean]' && (!toStringTag || !(_typeof$3(obj) === 'object' && toStringTag in obj));
  }

  // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && _typeof$3(obj) === 'object' && obj instanceof Symbol;
    }
    if (_typeof$3(obj) === 'symbol') {
      return true;
    }
    if (!obj || _typeof$3(obj) !== 'object' || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {}
    return false;
  }
  function isBigInt(obj) {
    if (!obj || _typeof$3(obj) !== 'object' || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {}
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function (key) {
    return key in this;
  };
  function has$3(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString$2.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
    if (m) {
      return m[1];
    }
    return null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || _typeof$3(x) !== 'object') {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return true;
      }
      return x instanceof Map; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || _typeof$3(x) !== 'object') {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || _typeof$3(x) !== 'object') {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {}
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || _typeof$3(x) !== 'object') {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return true;
      }
      return x instanceof Set; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || _typeof$3(x) !== 'object') {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return true;
      }
      return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
    } catch (e) {}
    return false;
  }
  function isElement(x) {
    if (!x || _typeof$3(x) !== 'object') {
      return false;
    }
    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    // eslint-disable-next-line no-control-regex
    var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s, 'single', opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: 'b',
      9: 't',
      10: 'n',
      12: 'f',
      13: 'r'
    }[n];
    if (x) {
      return '\\' + x;
    }
    return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str) {
    return 'Object(' + str + ')';
  }
  function weakCollectionOf(type) {
    return type + ' { ? }';
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
    return type + ' (' + size + ') {' + joinedEntries + '}';
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf(xs[i], '\n') >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === '\t') {
      baseIndent = '\t';
    } else if (typeof opts.indent === 'number' && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), ' ');
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return '';
    }
    var lineJoiner = '\n' + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray$4(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has$3(obj, i) ? inspect(obj[i], obj) : '';
      }
    }
    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap['$' + syms[k]] = syms[k];
      }
    }
    for (var key in obj) {
      // eslint-disable-line no-restricted-syntax
      if (!has$3(obj, key)) {
        continue;
      } // eslint-disable-line no-restricted-syntax, no-continue
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      } // eslint-disable-line no-restricted-syntax, no-continue
      if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
        // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
        continue; // eslint-disable-line no-restricted-syntax, no-continue
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
      } else {
        xs.push(key + ': ' + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === 'function') {
      for (var j = 0; j < syms.length; j++) {
        if (isEnumerable.call(obj, syms[j])) {
          xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
        }
      }
    }
    return xs;
  }

  var GetIntrinsic = getIntrinsic;
  var callBound = callBound$1;
  var inspect = objectInspect;
  var $TypeError = type;
  var $WeakMap = GetIntrinsic('%WeakMap%', true);
  var $Map = GetIntrinsic('%Map%', true);
  var $weakMapGet = callBound('WeakMap.prototype.get', true);
  var $weakMapSet = callBound('WeakMap.prototype.set', true);
  var $weakMapHas = callBound('WeakMap.prototype.has', true);
  var $mapGet = callBound('Map.prototype.get', true);
  var $mapSet = callBound('Map.prototype.set', true);
  var $mapHas = callBound('Map.prototype.has', true);

  /*
  * This function traverses the list returning the node corresponding to the given key.
  *
  * That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list. By doing so, all the recently used nodes can be accessed relatively quickly.
  */
  /** @type {import('.').listGetNode} */
  var listGetNode = function listGetNode(list, key) {
    // eslint-disable-line consistent-return
    /** @type {typeof list | NonNullable<(typeof list)['next']>} */
    var prev = list;
    /** @type {(typeof list)['next']} */
    var curr;
    for (; (curr = prev.next) !== null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        // eslint-disable-next-line no-extra-parens
        curr.next = /** @type {NonNullable<typeof list.next>} */list.next;
        list.next = curr; // eslint-disable-line no-param-reassign
        return curr;
      }
    }
  };

  /** @type {import('.').listGet} */
  var listGet = function listGet(objects, key) {
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  /** @type {import('.').listSet} */
  var listSet = function listSet(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      // Prepend the new node to the beginning of the list
      objects.next = /** @type {import('.').ListNode<typeof value>} */{
        // eslint-disable-line no-param-reassign, no-extra-parens
        key: key,
        next: objects.next,
        value: value
      };
    }
  };
  /** @type {import('.').listHas} */
  var listHas = function listHas(objects, key) {
    return !!listGetNode(objects, key);
  };

  /** @type {import('.')} */
  var sideChannel = function getSideChannel() {
    /** @type {WeakMap<object, unknown>} */var $wm;
    /** @type {Map<object, unknown>} */
    var $m;
    /** @type {import('.').RootNode<unknown>} */
    var $o;

    /** @type {import('.').Channel} */
    var channel = {
      assert: function assert(key) {
        if (!channel.has(key)) {
          throw new $TypeError('Side channel does not contain ' + inspect(key));
        }
      },
      get: function get(key) {
        // eslint-disable-line consistent-return
        if ($WeakMap && key && (_typeof$3(key) === 'object' || typeof key === 'function')) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapGet($m, key);
          }
        } else {
          if ($o) {
            // eslint-disable-line no-lonely-if
            return listGet($o, key);
          }
        }
      },
      has: function has(key) {
        if ($WeakMap && key && (_typeof$3(key) === 'object' || typeof key === 'function')) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapHas($m, key);
          }
        } else {
          if ($o) {
            // eslint-disable-line no-lonely-if
            return listHas($o, key);
          }
        }
        return false;
      },
      set: function set(key, value) {
        if ($WeakMap && key && (_typeof$3(key) === 'object' || typeof key === 'function')) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value);
        } else if ($Map) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        } else {
          if (!$o) {
            // Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
            $o = {
              key: {},
              next: null
            };
          }
          listSet($o, key, value);
        }
      }
    };
    return channel;
  };

  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
  };
  var formats$3 = {
    'default': Format.RFC3986,
    formatters: {
      RFC1738: function RFC1738(value) {
        return replace.call(value, percentTwenties, '+');
      },
      RFC3986: function RFC3986(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };

  var formats$2 = formats$3;
  var has$2 = Object.prototype.hasOwnProperty;
  var isArray$3 = Array.isArray;
  var hexTable = function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
      array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray$3(obj)) {
        var compacted = [];
        for (var j = 0; j < obj.length; ++j) {
          if (typeof obj[j] !== 'undefined') {
            compacted.push(obj[j]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== 'undefined') {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge = function merge(target, source, options) {
    /* eslint no-param-reassign: 0 */
    if (!source) {
      return target;
    }
    if (_typeof$3(source) !== 'object') {
      if (isArray$3(target)) {
        target.push(source);
      } else if (target && _typeof$3(target) === 'object') {
        if (options && (options.plainObjects || options.allowPrototypes) || !has$2.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || _typeof$3(target) !== 'object') {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray$3(target) && !isArray$3(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray$3(target) && isArray$3(source)) {
      source.forEach(function (item, i) {
        if (has$2.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && _typeof$3(targetItem) === 'object' && item && _typeof$3(item) === 'object') {
            target[i] = merge(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function (acc, key) {
      var value = source[key];
      if (has$2.call(acc, key)) {
        acc[key] = merge(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode = function decode(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
      // unescape never throws, no try...catch needed:
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;

  /* eslint operator-linebreak: [2, "before"] */

  var encode = function encode(str, defaultEncoder, charset, kind, format) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (_typeof$3(str) === 'symbol') {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== 'string') {
      string = String(str);
    }
    if (charset === 'iso-8859-1') {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
        return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
      });
    }
    var out = '';
    for (var j = 0; j < string.length; j += limit) {
      var segment = string.length >= limit ? string.slice(j, j + limit) : string;
      var arr = [];
      for (var i = 0; i < segment.length; ++i) {
        var c = segment.charCodeAt(i);
        if (c === 0x2D // -
        || c === 0x2E // .
        || c === 0x5F // _
        || c === 0x7E // ~
        || c >= 0x30 && c <= 0x39 // 0-9
        || c >= 0x41 && c <= 0x5A // a-z
        || c >= 0x61 && c <= 0x7A // A-Z
        || format === formats$2.RFC1738 && (c === 0x28 || c === 0x29) // ( )
        ) {
          arr[arr.length] = segment.charAt(i);
          continue;
        }
        if (c < 0x80) {
          arr[arr.length] = hexTable[c];
          continue;
        }
        if (c < 0x800) {
          arr[arr.length] = hexTable[0xC0 | c >> 6] + hexTable[0x80 | c & 0x3F];
          continue;
        }
        if (c < 0xD800 || c >= 0xE000) {
          arr[arr.length] = hexTable[0xE0 | c >> 12] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
          continue;
        }
        i += 1;
        c = 0x10000 + ((c & 0x3FF) << 10 | segment.charCodeAt(i) & 0x3FF);
        arr[arr.length] = hexTable[0xF0 | c >> 18] + hexTable[0x80 | c >> 12 & 0x3F] + hexTable[0x80 | c >> 6 & 0x3F] + hexTable[0x80 | c & 0x3F];
      }
      out += arr.join('');
    }
    return out;
  };
  var compact = function compact(value) {
    var queue = [{
      obj: {
        o: value
      },
      prop: 'o'
    }];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j = 0; j < keys.length; ++j) {
        var key = keys[j];
        var val = obj[key];
        if (_typeof$3(val) === 'object' && val !== null && refs.indexOf(val) === -1) {
          queue.push({
            obj: obj,
            prop: key
          });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value;
  };
  var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
  };
  var isBuffer = function isBuffer(obj) {
    if (!obj || _typeof$3(obj) !== 'object') {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap(val, fn) {
    if (isArray$3(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  var utils$2 = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    maybeMap: maybeMap,
    merge: merge
  };

  var getSideChannel = sideChannel;
  var utils$1 = utils$2;
  var formats$1 = formats$3;
  var has$1 = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) {
      return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray$2 = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function pushToArray(arr, valueOrArray) {
    push.apply(arr, isArray$2(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats$1['default'];
  var defaults$1 = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: 'indices',
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encodeDotInKeys: false,
    encoder: utils$1.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats$1.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive(v) {
    return typeof v === 'string' || typeof v === 'number' || typeof v === 'boolean' || _typeof$3(v) === 'symbol' || typeof v === 'bigint';
  };
  var sentinel = {};
  var stringify$2 = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {
      // Where object last appeared in the ref tree
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== 'undefined') {
        if (pos === step) {
          throw new RangeError('Cyclic object value');
        } else {
          findFlag = true; // Break while
        }
      }
      if (typeof tmpSc.get(sentinel) === 'undefined') {
        step = 0;
      }
    }
    if (typeof filter === 'function') {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray$2(obj)) {
      obj = utils$1.maybeMap(obj, function (value) {
        if (value instanceof Date) {
          return serializeDate(value);
        }
        return value;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder, charset, 'key', format) : prefix;
      }
      obj = '';
    }
    if (isNonNullishPrimitive(obj) || utils$1.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder, charset, 'key', format);
        return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults$1.encoder, charset, 'value', format))];
      }
      return [formatter(prefix) + '=' + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === 'undefined') {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === 'comma' && isArray$2(obj)) {
      // we need to join elements in
      if (encodeValuesOnly && encoder) {
        obj = utils$1.maybeMap(obj, encoder);
      }
      objKeys = [{
        value: obj.length > 0 ? obj.join(',') || null : void undefined
      }];
    } else if (isArray$2(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, '%2E') : prefix;
    var adjustedPrefix = commaRoundTrip && isArray$2(obj) && obj.length === 1 ? encodedPrefix + '[]' : encodedPrefix;
    if (allowEmptyArrays && isArray$2(obj) && obj.length === 0) {
      return adjustedPrefix + '[]';
    }
    for (var j = 0; j < objKeys.length; ++j) {
      var key = objKeys[j];
      var value = _typeof$3(key) === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, '%2E') : key;
      var keyPrefix = isArray$2(obj) ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? '.' + encodedKey : '[' + encodedKey + ']');
      sideChannel.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel);
      pushToArray(values, stringify(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === 'comma' && encodeValuesOnly && isArray$2(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
      return defaults$1;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
      throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.encodeDotInKeys !== 'undefined' && typeof opts.encodeDotInKeys !== 'boolean') {
      throw new TypeError('`encodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {
      throw new TypeError('Encoder has to be a function.');
    }
    var charset = opts.charset || defaults$1.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
      throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var format = formats$1['default'];
    if (typeof opts.format !== 'undefined') {
      if (!has$1.call(formats$1.formatters, opts.format)) {
        throw new TypeError('Unknown format option provided.');
      }
      format = opts.format;
    }
    var formatter = formats$1.formatters[format];
    var filter = defaults$1.filter;
    if (typeof opts.filter === 'function' || isArray$2(opts.filter)) {
      filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ('indices' in opts) {
      arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
      arrayFormat = defaults$1.arrayFormat;
    }
    if ('commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {
      throw new TypeError('`commaRoundTrip` must be a boolean, or absent');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.encodeDotInKeys === true ? true : defaults$1.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults$1.addQueryPrefix,
      allowDots: allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults$1.allowEmptyArrays,
      arrayFormat: arrayFormat,
      charset: charset,
      charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults$1.charsetSentinel,
      commaRoundTrip: opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === 'undefined' ? defaults$1.delimiter : opts.delimiter,
      encode: typeof opts.encode === 'boolean' ? opts.encode : defaults$1.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === 'boolean' ? opts.encodeDotInKeys : defaults$1.encodeDotInKeys,
      encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults$1.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults$1.encodeValuesOnly,
      filter: filter,
      format: format,
      formatter: formatter,
      serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults$1.serializeDate,
      skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults$1.skipNulls,
      sort: typeof opts.sort === 'function' ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults$1.strictNullHandling
    };
  };
  var stringify_1 = function stringify_1(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === 'function') {
      filter = options.filter;
      obj = filter('', obj);
    } else if (isArray$2(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (_typeof$3(obj) !== 'object' || obj === null) {
      return '';
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === 'comma' && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys, stringify$2(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';
    if (options.charsetSentinel) {
      if (options.charset === 'iso-8859-1') {
        // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
        prefix += 'utf8=%26%2310003%3B&';
      } else {
        // encodeURIComponent('✓')
        prefix += 'utf8=%E2%9C%93&';
      }
    }
    return joined.length > 0 ? prefix + joined : '';
  };

  var utils = utils$2;
  var has = Object.prototype.hasOwnProperty;
  var isArray$1 = Array.isArray;
  var defaults = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    duplicates: 'combine',
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function interpretNumericEntities(str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function parseArrayValue(val, options) {
    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {
      return val.split(',');
    }
    return val;
  };

  // This is what browsers will submit when the ✓ character occurs in an
  // application/x-www-form-urlencoded body and the encoding of the page containing
  // the form is iso-8859-1, or when the submitted form has an accept-charset
  // attribute of iso-8859-1. Presumably also with other charsets that do not contain
  // the ✓ character, such as us-ascii.
  var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

  // These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
  var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {
      __proto__: null
    };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    cleanStr = cleanStr.replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf('utf8=') === 0) {
          if (parts[i] === charsetSentinel) {
            charset = 'utf-8';
          } else if (parts[i] === isoSentinel) {
            charset = 'iso-8859-1';
          }
          skipIndex = i;
          i = parts.length; // The eslint settings do not allow break;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf(']=');
      var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults.decoder, charset, 'key');
        val = options.strictNullHandling ? null : '';
      } else {
        key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');
        val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function (encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, 'value');
        });
      }
      if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
        val = interpretNumericEntities(val);
      }
      if (part.indexOf('[]=') > -1) {
        val = isArray$1(val) ? [val] : val;
      }
      var existing = has.call(obj, key);
      if (existing && options.duplicates === 'combine') {
        obj[key] = utils.combine(obj[key], val);
      } else if (!existing || options.duplicates === 'last') {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function parseObject(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root = chain[i];
      if (root === '[]' && options.parseArrays) {
        obj = options.allowEmptyArrays && (leaf === '' || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
      } else {
        obj = options.plainObjects ? Object.create(null) : {};
        var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, '.') : cleanRoot;
        var index = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === '') {
          obj = {
            0: leaf
          };
        } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
          obj = [];
          obj[index] = leaf;
        } else if (decodedRoot !== '__proto__') {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
      // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }

    // If there's a remainder, check strictDepth option for throw, else just add whatever is left

    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError('Input depth exceeded depth option of ' + options.depth + ' and strictDepth is true');
      }
      keys.push('[' + key.slice(segment.index) + ']');
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
      return defaults;
    }
    if (typeof opts.allowEmptyArrays !== 'undefined' && typeof opts.allowEmptyArrays !== 'boolean') {
      throw new TypeError('`allowEmptyArrays` option can only be `true` or `false`, when provided');
    }
    if (typeof opts.decodeDotInKeys !== 'undefined' && typeof opts.decodeDotInKeys !== 'boolean') {
      throw new TypeError('`decodeDotInKeys` option can only be `true` or `false`, when provided');
    }
    if (opts.decoder !== null && typeof opts.decoder !== 'undefined' && typeof opts.decoder !== 'function') {
      throw new TypeError('Decoder has to be a function.');
    }
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
      throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;
    var duplicates = typeof opts.duplicates === 'undefined' ? defaults.duplicates : opts.duplicates;
    if (duplicates !== 'combine' && duplicates !== 'first' && duplicates !== 'last') {
      throw new TypeError('The duplicates option must be either combine, first, or last');
    }
    var allowDots = typeof opts.allowDots === 'undefined' ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
    return {
      allowDots: allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === 'boolean' ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
      allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,
      arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
      charset: charset,
      charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
      comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === 'boolean' ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
      decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
      delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === 'number' || opts.depth === false ? +opts.depth : defaults.depth,
      duplicates: duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
      strictDepth: typeof opts.strictDepth === 'boolean' ? !!opts.strictDepth : defaults.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
  };
  var parse$1 = function parse(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === '' || str === null || typeof str === 'undefined') {
      return options.plainObjects ? Object.create(null) : {};
    }
    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');
      obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils.compact(obj);
  };

  var stringify$1 = stringify_1;
  var parse = parse$1;
  var formats = formats$3;
  var lib = {
    formats: formats,
    parse: parse,
    stringify: stringify$1
  };
  var qs = /*@__PURE__*/getDefaultExportFromCjs(lib);

  /** `Object#toString` result references. */
  var stringTag = '[object String]';

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /**
   * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString$1 = objectProto$1.toString;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike$1(value) {
    return !!value && _typeof$3(value) == 'object';
  }

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' || !isArray(value) && isObjectLike$1(value) && objectToString$1.call(value) == stringTag;
  }
  var lodash_isstring = isString;
  var isString$1 = /*@__PURE__*/getDefaultExportFromCjs(lodash_isstring);

  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }

  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _typeof$3(e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }

  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, _getPrototypeOf(t);
  }

  function _setPrototypeOf$1(t, e) {
    return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf$1(t, e);
  }

  function _inherits$1(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(t, "prototype", {
      writable: !1
    }), e && _setPrototypeOf$1(t, e);
  }

  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }

  function _isNativeReflectConstruct$3() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (_isNativeReflectConstruct$3 = function _isNativeReflectConstruct() {
      return !!t;
    })();
  }

  function _construct(t, e, r) {
    if (_isNativeReflectConstruct$3()) return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _setPrototypeOf$1(p, r.prototype), p;
  }

  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : void 0;
    return _wrapNativeSuper = function _wrapNativeSuper(t) {
      if (null === t || !_isNativeFunction(t)) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r) {
        if (r.has(t)) return r.get(t);
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _construct(t, arguments, _getPrototypeOf(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _setPrototypeOf$1(Wrapper, t);
    }, _wrapNativeSuper(t);
  }

  var pThrottle$2 = {exports: {}};

  function _createForOfIteratorHelper$2(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray$2(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
  function _unsupportedIterableToArray$2(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray$2(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$2(r, a) : void 0; } }
  function _arrayLikeToArray$2(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  function _callSuper$2(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$2() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct$2() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$2 = function _isNativeReflectConstruct() { return !!t; })(); }
  var AbortError = /*#__PURE__*/function (_Error) {
    function AbortError() {
      var _this;
      _classCallCheck(this, AbortError);
      _this = _callSuper$2(this, AbortError, ['Throttled function aborted']);
      _this.name = 'AbortError';
      return _this;
    }
    _inherits$1(AbortError, _Error);
    return _createClass(AbortError);
  }(/*#__PURE__*/_wrapNativeSuper(Error));
  var pThrottle = function pThrottle(_ref) {
    var limit = _ref.limit,
      interval = _ref.interval,
      strict = _ref.strict;
    if (!Number.isFinite(limit)) {
      throw new TypeError('Expected `limit` to be a finite number');
    }
    if (!Number.isFinite(interval)) {
      throw new TypeError('Expected `interval` to be a finite number');
    }
    var queue = new Map();
    var currentTick = 0;
    var activeCount = 0;
    function windowedDelay() {
      var now = Date.now();
      if (now - currentTick > interval) {
        activeCount = 1;
        currentTick = now;
        return 0;
      }
      if (activeCount < limit) {
        activeCount++;
      } else {
        currentTick += interval;
        activeCount = 1;
      }
      return currentTick - now;
    }
    var strictTicks = [];
    function strictDelay() {
      var now = Date.now();
      if (strictTicks.length < limit) {
        strictTicks.push(now);
        return 0;
      }
      var earliestTime = strictTicks.shift() + interval;
      if (now >= earliestTime) {
        strictTicks.push(now);
        return 0;
      }
      strictTicks.push(earliestTime);
      return earliestTime - now;
    }
    var getDelay = strict ? strictDelay : windowedDelay;
    return function (function_) {
      var _throttled = function throttled() {
        var _this2 = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (!_throttled.isEnabled) {
          return _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee() {
            return _regeneratorRuntime$1.wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", function_.apply(_this2, args));
                case 1:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }))();
        }
        var timeout;
        return new Promise(function (resolve, reject) {
          var execute = function execute() {
            resolve(function_.apply(_this2, args));
            queue.delete(timeout);
          };
          timeout = setTimeout(execute, getDelay());
          queue.set(timeout, reject);
        });
      };
      _throttled.abort = function () {
        var _iterator = _createForOfIteratorHelper$2(queue.keys()),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var timeout = _step.value;
            clearTimeout(timeout);
            queue.get(timeout)(new AbortError());
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        queue.clear();
        strictTicks.splice(0, strictTicks.length);
      };
      _throttled.isEnabled = true;
      return _throttled;
    };
  };
  pThrottle$2.exports = pThrottle;
  pThrottle$2.exports.AbortError = AbortError;
  var pThrottleExports = pThrottle$2.exports;
  var pThrottle$1 = /*@__PURE__*/getDefaultExportFromCjs(pThrottleExports);

  /** `Object#toString` result references. */
  var objectTag = '[object Object]';

  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */
  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
    objectProto = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString.call(Object);

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto.toString;

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && _typeof$3(value) == 'object';
  }

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  var lodash_isplainobject = isPlainObject;
  var isPlainObject$1 = /*@__PURE__*/getDefaultExportFromCjs(lodash_isplainobject);

  function _arrayLikeToArray$1(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c),
        u = i.value;
    } catch (n) {
      return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function () {
      var t = this,
        e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
        }
        function _throw(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
        }
        _next(void 0);
      });
    };
  }
  function _createForOfIteratorHelper$1(r, e) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray$1(r)) || e) {
        t && (r = t);
        var _n = 0,
          F = function F() {};
        return {
          s: F,
          n: function n() {
            return _n >= r.length ? {
              done: !0
            } : {
              done: !1,
              value: r[_n++]
            };
          },
          e: function e(r) {
            throw r;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o,
      a = !0,
      u = !1;
    return {
      s: function s() {
        t = t.call(r);
      },
      n: function n() {
        var r = t.next();
        return a = r.done, r;
      },
      e: function e(r) {
        u = !0, o = r;
      },
      f: function f() {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      }
    };
  }
  function _defineProperty(e, r, t) {
    return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(t, "prototype", {
      writable: !1
    }), e && _setPrototypeOf(t, e);
  }
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function ownKeys(e, r) {
    var t = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e);
      r && (o = o.filter(function (r) {
        return Object.getOwnPropertyDescriptor(e, r).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread2(e) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
        _defineProperty(e, r, t[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
      });
    }
    return e;
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function _regeneratorRuntime() {
      return e;
    };
    var t,
      e = {},
      r = Object.prototype,
      n = r.hasOwnProperty,
      o = Object.defineProperty || function (t, e, r) {
        t[e] = r.value;
      },
      i = "function" == typeof Symbol ? Symbol : {},
      a = i.iterator || "@@iterator",
      c = i.asyncIterator || "@@asyncIterator",
      u = i.toStringTag || "@@toStringTag";
    function define(t, e, r) {
      return Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), t[e];
    }
    try {
      define({}, "");
    } catch (t) {
      define = function define(t, e, r) {
        return t[e] = r;
      };
    }
    function wrap(t, e, r, n) {
      var i = e && e.prototype instanceof Generator ? e : Generator,
        a = Object.create(i.prototype),
        c = new Context(n || []);
      return o(a, "_invoke", {
        value: makeInvokeMethod(t, r, c)
      }), a;
    }
    function tryCatch(t, e, r) {
      try {
        return {
          type: "normal",
          arg: t.call(e, r)
        };
      } catch (t) {
        return {
          type: "throw",
          arg: t
        };
      }
    }
    e.wrap = wrap;
    var h = "suspendedStart",
      l = "suspendedYield",
      f = "executing",
      s = "completed",
      y = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var p = {};
    define(p, a, function () {
      return this;
    });
    var d = Object.getPrototypeOf,
      v = d && d(d(values([])));
    v && v !== r && n.call(v, a) && (p = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
    function defineIteratorMethods(t) {
      ["next", "throw", "return"].forEach(function (e) {
        define(t, e, function (t) {
          return this._invoke(e, t);
        });
      });
    }
    function AsyncIterator(t, e) {
      function invoke(r, o, i, a) {
        var c = tryCatch(t[r], t, o);
        if ("throw" !== c.type) {
          var u = c.arg,
            h = u.value;
          return h && "object" == _typeof$3(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
            invoke("next", t, i, a);
          }, function (t) {
            invoke("throw", t, i, a);
          }) : e.resolve(h).then(function (t) {
            u.value = t, i(u);
          }, function (t) {
            return invoke("throw", t, i, a);
          });
        }
        a(c.arg);
      }
      var r;
      o(this, "_invoke", {
        value: function value(t, n) {
          function callInvokeWithMethodAndArg() {
            return new e(function (e, r) {
              invoke(t, n, e, r);
            });
          }
          return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e, r, n) {
      var o = h;
      return function (i, a) {
        if (o === f) throw Error("Generator is already running");
        if (o === s) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          };
        }
        for (n.method = i, n.arg = a;;) {
          var c = n.delegate;
          if (c) {
            var u = maybeInvokeDelegate(c, n);
            if (u) {
              if (u === y) continue;
              return u;
            }
          }
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (o === h) throw o = s, n.arg;
            n.dispatchException(n.arg);
          } else "return" === n.method && n.abrupt("return", n.arg);
          o = f;
          var p = tryCatch(e, r, n);
          if ("normal" === p.type) {
            if (o = n.done ? s : l, p.arg === y) continue;
            return {
              value: p.arg,
              done: n.done
            };
          }
          "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
        }
      };
    }
    function maybeInvokeDelegate(e, r) {
      var n = r.method,
        o = e.iterator[n];
      if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
      var i = tryCatch(o, e.iterator, r.arg);
      if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
      var a = i.arg;
      return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
    }
    function pushTryEntry(t) {
      var e = {
        tryLoc: t[0]
      };
      1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
    }
    function resetTryEntry(t) {
      var e = t.completion || {};
      e.type = "normal", delete e.arg, t.completion = e;
    }
    function Context(t) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(e) {
      if (e || "" === e) {
        var r = e[a];
        if (r) return r.call(e);
        if ("function" == typeof e.next) return e;
        if (!isNaN(e.length)) {
          var o = -1,
            i = function next() {
              for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
              return next.value = t, next.done = !0, next;
            };
          return i.next = i;
        }
      }
      throw new TypeError(_typeof$3(e) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: !0
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
      var e = "function" == typeof t && t.constructor;
      return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
    }, e.mark = function (t) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
    }, e.awrap = function (t) {
      return {
        __await: t
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
      return this;
    }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
      void 0 === i && (i = Promise);
      var a = new AsyncIterator(wrap(t, r, n, o), i);
      return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
        return t.done ? t.value : a.next();
      });
    }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
      return this;
    }), define(g, "toString", function () {
      return "[object Generator]";
    }), e.keys = function (t) {
      var e = Object(t),
        r = [];
      for (var n in e) r.push(n);
      return r.reverse(), function next() {
        for (; r.length;) {
          var t = r.pop();
          if (t in e) return next.value = t, next.done = !1, next;
        }
        return next.done = !0, next;
      };
    }, e.values = values, Context.prototype = {
      constructor: Context,
      reset: function reset(e) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
      },
      stop: function stop() {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e) {
        if (this.done) throw e;
        var r = this;
        function handle(n, o) {
          return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var i = this.tryEntries[o],
            a = i.completion;
          if ("root" === i.tryLoc) return handle("end");
          if (i.tryLoc <= this.prev) {
            var c = n.call(i, "catchLoc"),
              u = n.call(i, "finallyLoc");
            if (c && u) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            } else if (c) {
              if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            } else {
              if (!u) throw Error("try statement without catch or finally");
              if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t, e) {
        for (var r = this.tryEntries.length - 1; r >= 0; --r) {
          var o = this.tryEntries[r];
          if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
            var i = o;
            break;
          }
        }
        i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
        var a = i ? i.completion : {};
        return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
      },
      complete: function complete(t, e) {
        if ("throw" === t.type) throw t.arg;
        return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
      },
      finish: function finish(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
        }
      },
      catch: function _catch(t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var r = this.tryEntries[e];
          if (r.tryLoc === t) {
            var n = r.completion;
            if ("throw" === n.type) {
              var o = n.arg;
              resetTryEntry(r);
            }
            return o;
          }
        }
        throw Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e, r, n) {
        return this.delegate = {
          iterator: values(e),
          resultName: r,
          nextLoc: n
        }, "next" === this.method && (this.arg = t), y;
      }
    }, e;
  }
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, _setPrototypeOf(t, e);
  }
  function _slicedToArray$1(r, e) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray$1(r, e) || _nonIterableRest();
  }
  function _toPrimitive(t, r) {
    if ("object" != _typeof$3(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _typeof$3(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == _typeof$3(i) ? i : i + "";
  }
  function _typeof$1(o) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof$1(o);
  }
  function _unsupportedIterableToArray$1(r, a) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray$1(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray$1(r, a) : void 0;
    }
  }
  function _wrapRegExp() {
    _wrapRegExp = function _wrapRegExp(e, r) {
      return new BabelRegExp(e, void 0, r);
    };
    var e = RegExp.prototype,
      r = new WeakMap();
    function BabelRegExp(e, t, p) {
      var o = RegExp(e, t);
      return r.set(o, p || r.get(e)), _setPrototypeOf(o, BabelRegExp.prototype);
    }
    function buildGroups(e, t) {
      var p = r.get(t);
      return Object.keys(p).reduce(function (r, t) {
        var o = p[t];
        if ("number" == typeof o) r[t] = e[o];else {
          for (var i = 0; void 0 === e[o[i]] && i + 1 < o.length;) i++;
          r[t] = e[o[i]];
        }
        return r;
      }, Object.create(null));
    }
    return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (r) {
      var t = e.exec.call(this, r);
      if (t) {
        t.groups = buildGroups(t, this);
        var p = t.indices;
        p && (p.groups = buildGroups(p, this));
      }
      return t;
    }, BabelRegExp.prototype[Symbol.replace] = function (t, p) {
      if ("string" == typeof p) {
        var o = r.get(this);
        return e[Symbol.replace].call(this, t, p.replace(/\$<([^>]+)>/g, function (e, r) {
          var t = o[r];
          return "$" + (Array.isArray(t) ? t.join("$") : t);
        }));
      }
      if ("function" == typeof p) {
        var i = this;
        return e[Symbol.replace].call(this, t, function () {
          var e = arguments;
          return "object" != _typeof$3(e[e.length - 1]) && (e = [].slice.call(e)).push(buildGroups(e, i)), p.apply(this, e);
        });
      }
      return e[Symbol.replace].call(this, t, p);
    }, _wrapRegExp.apply(this, arguments);
  }
  function asyncToken(instance, getToken) {
    instance.interceptors.request.use(function (config) {
      return getToken().then(function (accessToken) {
        config.headers.set('Authorization', "Bearer ".concat(accessToken));
        return config;
      });
    });
  }
  function isNode() {
    /**
     * Polyfills of 'process' might set process.browser === true
     *
     * See:
     * https://github.com/webpack/node-libs-browser/blob/master/mock/process.js#L8
     * https://github.com/defunctzombie/node-process/blob/master/browser.js#L156
     **/
    return typeof process !== 'undefined' && !process.browser;
  }
  function isReactNative() {
    return typeof window !== 'undefined' && 'navigator' in window && 'product' in window.navigator && window.navigator.product === 'ReactNative';
  }
  function getNodeVersion() {
    return process.versions && process.versions.node ? "v".concat(process.versions.node) : process.version;
  }
  function getWindow() {
    return window;
  }
  function noop() {
    return undefined;
  }
  var delay = function delay(ms) {
    return new Promise(function (resolve) {
      setTimeout(resolve, ms);
    });
  };
  var defaultWait = function defaultWait(attempts) {
    return Math.pow(Math.SQRT2, attempts);
  };
  function rateLimit(instance) {
    var maxRetry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;
    var _instance$defaults = instance.defaults,
      _instance$defaults$re = _instance$defaults.responseLogger,
      responseLogger = _instance$defaults$re === void 0 ? noop : _instance$defaults$re,
      _instance$defaults$re2 = _instance$defaults.requestLogger,
      requestLogger = _instance$defaults$re2 === void 0 ? noop : _instance$defaults$re2;
    instance.interceptors.request.use(function (config) {
      requestLogger(config);
      return config;
    }, function (error) {
      requestLogger(error);
      return Promise.reject(error);
    });
    instance.interceptors.response.use(function (response) {
      // we don't need to do anything here
      responseLogger(response);
      return response;
    }, /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(error) {
        var response, config, doneAttempts, retryErrorType, wait;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              response = error.response;
              config = error.config;
              responseLogger(error);
              // Do not retry if it is disabled or no request config exists (not an axios error)
              if (!(!config || !instance.defaults.retryOnError)) {
                _context.next = 5;
                break;
              }
              return _context.abrupt("return", Promise.reject(error));
            case 5:
              // Retried already for max attempts
              doneAttempts = config.attempts || 1;
              if (!(doneAttempts > maxRetry)) {
                _context.next = 9;
                break;
              }
              error.attempts = config.attempts;
              return _context.abrupt("return", Promise.reject(error));
            case 9:
              retryErrorType = null;
              wait = defaultWait(doneAttempts); // Errors without response did not receive anything from the server
              if (!response) {
                retryErrorType = 'Connection';
              } else if (response.status >= 500 && response.status < 600) {
                // 5** errors are server related
                retryErrorType = "Server ".concat(response.status);
              } else if (response.status === 429) {
                // 429 errors are exceeded rate limit exceptions
                retryErrorType = 'Rate limit';
                // all headers are lowercased by axios https://github.com/mzabriskie/axios/issues/413
                if (response.headers && error.response.headers['x-contentful-ratelimit-reset']) {
                  wait = response.headers['x-contentful-ratelimit-reset'];
                }
              }
              if (!retryErrorType) {
                _context.next = 19;
                break;
              }
              // convert to ms and add jitter
              wait = Math.floor(wait * 1000 + Math.random() * 200 + 500);
              instance.defaults.logHandler('warning', "".concat(retryErrorType, " error occurred. Waiting for ").concat(wait, " ms before retrying..."));

              // increase attempts counter
              config.attempts = doneAttempts + 1;

              /* Somehow between the interceptor and retrying the request the httpAgent/httpsAgent gets transformed from an Agent-like object
               to a regular object, causing failures on retries after rate limits. Removing these properties here fixes the error, but retry
               requests still use the original http/httpsAgent property */
              delete config.httpAgent;
              delete config.httpsAgent;
              return _context.abrupt("return", delay(wait).then(function () {
                return instance(config);
              }));
            case 19:
              return _context.abrupt("return", Promise.reject(error));
            case 20:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
  }
  var PERCENTAGE_REGEX = /*#__PURE__*/_wrapRegExp(/(\d+)(%)/, {
    value: 1
  });
  function calculateLimit(type) {
    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;
    var limit = max;
    if (PERCENTAGE_REGEX.test(type)) {
      var _type$match;
      var groups = (_type$match = type.match(PERCENTAGE_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match.groups;
      if (groups && groups.value) {
        var percentage = parseInt(groups.value) / 100;
        limit = Math.round(max * percentage);
      }
    }
    return Math.min(30, Math.max(1, limit));
  }
  function createThrottle(limit, logger) {
    logger('info', "Throttle request to ".concat(limit, "/s"));
    return pThrottle$1({
      limit: limit,
      interval: 1000,
      strict: false
    });
  }
  var rateLimitThrottle = function rateLimitThrottle(axiosInstance) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';
    var _axiosInstance$defaul = axiosInstance.defaults.logHandler,
      logHandler = _axiosInstance$defaul === void 0 ? noop : _axiosInstance$defaul;
    var limit = isString$1(type) ? calculateLimit(type) : calculateLimit('auto', type);
    var throttle = createThrottle(limit, logHandler);
    var isCalculated = false;
    var requestInterceptorId = axiosInstance.interceptors.request.use(function (config) {
      return throttle(function () {
        return config;
      })();
    }, function (error) {
      return Promise.reject(error);
    });
    var responseInterceptorId = axiosInstance.interceptors.response.use(function (response) {
      if (!isCalculated && isString$1(type) && (type === 'auto' || PERCENTAGE_REGEX.test(type)) && response.headers && response.headers['x-contentful-ratelimit-second-limit']) {
        var rawLimit = parseInt(response.headers['x-contentful-ratelimit-second-limit']);
        var nextLimit = calculateLimit(type, rawLimit);
        if (nextLimit !== limit) {
          if (requestInterceptorId) {
            axiosInstance.interceptors.request.eject(requestInterceptorId);
          }
          limit = nextLimit;
          throttle = createThrottle(nextLimit, logHandler);
          requestInterceptorId = axiosInstance.interceptors.request.use(function (config) {
            return throttle(function () {
              return config;
            })();
          }, function (error) {
            return Promise.reject(error);
          });
        }
        isCalculated = true;
      }
      return response;
    }, function (error) {
      return Promise.reject(error);
    });
    return function () {
      axiosInstance.interceptors.request.eject(requestInterceptorId);
      axiosInstance.interceptors.response.eject(responseInterceptorId);
    };
  };

  // Matches 'sub.host:port' or 'host:port' and extracts hostname and port
  // Also enforces toplevel domain specified, no spaces and no protocol
  var HOST_REGEX = /^(?!\w+:\/\/)([^\s:]+\.?[^\s:]+)(?::(\d+))?(?!:)$/;

  /**
   * Create pre-configured axios instance
   * @private
   * @param {AxiosStatic} axios - Axios library
   * @param {CreateHttpClientParams} options - Initialization parameters for the HTTP client
   * @return {AxiosInstance} Initialized axios instance
   */
  function createHttpClient(axios, options) {
    var defaultConfig = {
      insecure: false,
      retryOnError: true,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      logHandler: function logHandler(level, data) {
        if (level === 'error' && data) {
          var title = [data.name, data.message].filter(function (a) {
            return a;
          }).join(' - ');
          console.error("[error] ".concat(title));
          console.error(data);
          return;
        }
        console.log("[".concat(level, "] ").concat(data));
      },
      // Passed to axios
      headers: {},
      httpAgent: false,
      httpsAgent: false,
      timeout: 30000,
      throttle: 0,
      basePath: '',
      adapter: undefined,
      maxContentLength: 1073741824,
      // 1GB
      maxBodyLength: 1073741824 // 1GB
    };
    var config = _objectSpread2(_objectSpread2({}, defaultConfig), options);
    if (!config.accessToken) {
      var missingAccessTokenError = new TypeError('Expected parameter accessToken');
      config.logHandler('error', missingAccessTokenError);
      throw missingAccessTokenError;
    }

    // Construct axios baseURL option
    var protocol = config.insecure ? 'http' : 'https';
    var space = config.space ? "".concat(config.space, "/") : '';
    var hostname = config.defaultHostname;
    var port = config.insecure ? 80 : 443;
    if (config.host && HOST_REGEX.test(config.host)) {
      var parsed = config.host.split(':');
      if (parsed.length === 2) {
        var _parsed = _slicedToArray$1(parsed, 2);
        hostname = _parsed[0];
        port = _parsed[1];
      } else {
        hostname = parsed[0];
      }
    }

    // Ensure that basePath does start but not end with a slash
    if (config.basePath) {
      config.basePath = "/".concat(config.basePath.split('/').filter(Boolean).join('/'));
    }
    var baseURL = options.baseURL || "".concat(protocol, "://").concat(hostname, ":").concat(port).concat(config.basePath, "/spaces/").concat(space);
    if (!config.headers.Authorization && typeof config.accessToken !== 'function') {
      config.headers.Authorization = 'Bearer ' + config.accessToken;
    }
    var axiosOptions = {
      // Axios
      baseURL: baseURL,
      headers: config.headers,
      httpAgent: config.httpAgent,
      httpsAgent: config.httpsAgent,
      proxy: config.proxy,
      timeout: config.timeout,
      adapter: config.adapter,
      maxContentLength: config.maxContentLength,
      maxBodyLength: config.maxBodyLength,
      paramsSerializer: {
        serialize: function serialize(params) {
          return qs.stringify(params);
        }
      },
      // Contentful
      logHandler: config.logHandler,
      responseLogger: config.responseLogger,
      requestLogger: config.requestLogger,
      retryOnError: config.retryOnError
    };
    var instance = axios.create(axiosOptions);
    instance.httpClientParams = options;

    /**
     * Creates a new axios instance with the same default base parameters as the
     * current one, and with any overrides passed to the newParams object
     * This is useful as the SDKs use dependency injection to get the axios library
     * and the version of the library comes from different places depending
     * on whether it's a browser build or a node.js build.
     * @private
     * @param {CreateHttpClientParams} newParams - Initialization parameters for the HTTP client
     * @return {AxiosInstance} Initialized axios instance
     */
    instance.cloneWithNewParams = function (newParams) {
      return createHttpClient(axios, _objectSpread2(_objectSpread2({}, copy$1(options)), newParams));
    };

    /**
     * Apply interceptors.
     * Please note that the order of interceptors is important
     */

    if (config.onBeforeRequest) {
      instance.interceptors.request.use(config.onBeforeRequest);
    }
    if (typeof config.accessToken === 'function') {
      asyncToken(instance, config.accessToken);
    }
    if (config.throttle) {
      rateLimitThrottle(instance, config.throttle);
    }
    rateLimit(instance, config.retryLimit);
    if (config.onError) {
      instance.interceptors.response.use(function (response) {
        return response;
      }, config.onError);
    }
    return instance;
  }

  /* eslint-disable @typescript-eslint/no-explicit-any */
  /**
   * Creates request parameters configuration by parsing an existing query object
   * @private
   * @param {Object} query
   * @return {Object} Config object with `params` property, ready to be used in axios
   */
  function createRequestConfig(_ref) {
    var query = _ref.query;
    var config = {};
    delete query.resolveLinks;
    config.params = copy$1(query);
    return config;
  }

  // copied from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze

  function deepFreeze(object) {
    var propNames = Object.getOwnPropertyNames(object);
    var _iterator = _createForOfIteratorHelper$1(propNames),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var name = _step.value;
        var value = object[name];
        if (value && _typeof$1(value) === 'object') {
          deepFreeze(value);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return Object.freeze(object);
  }
  function freezeSys(obj) {
    deepFreeze(obj.sys || {});
    return obj;
  }
  function getBrowserOS() {
    var win = getWindow();
    if (!win) {
      return null;
    }
    var userAgent = win.navigator.userAgent;
    // TODO: platform is deprecated.
    var platform = win.navigator.platform;
    var macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];
    var windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];
    var iosPlatforms = ['iPhone', 'iPad', 'iPod'];
    if (macosPlatforms.indexOf(platform) !== -1) {
      return 'macOS';
    } else if (iosPlatforms.indexOf(platform) !== -1) {
      return 'iOS';
    } else if (windowsPlatforms.indexOf(platform) !== -1) {
      return 'Windows';
    } else if (/Android/.test(userAgent)) {
      return 'Android';
    } else if (/Linux/.test(platform)) {
      return 'Linux';
    }
    return null;
  }
  function getNodeOS() {
    var platform = process.platform || 'linux';
    var version = process.version || '0.0.0';
    var platformMap = {
      android: 'Android',
      aix: 'Linux',
      darwin: 'macOS',
      freebsd: 'Linux',
      linux: 'Linux',
      openbsd: 'Linux',
      sunos: 'Linux',
      win32: 'Windows'
    };
    if (platform in platformMap) {
      return "".concat(platformMap[platform] || 'Linux', "/").concat(version);
    }
    return null;
  }
  function getUserAgentHeader(sdk, application, integration, feature) {
    var headerParts = [];
    if (application) {
      headerParts.push("app ".concat(application));
    }
    if (integration) {
      headerParts.push("integration ".concat(integration));
    }
    headerParts.push("sdk ".concat(sdk));
    var platform = null;
    try {
      if (isReactNative()) {
        platform = getBrowserOS();
        headerParts.push('platform ReactNative');
      } else if (isNode()) {
        platform = getNodeOS();
        headerParts.push("platform node.js/".concat(getNodeVersion()));
      } else {
        platform = getBrowserOS();
        headerParts.push('platform browser');
      }
    } catch (e) {
      platform = null;
    }
    if (platform) {
      headerParts.push("os ".concat(platform));
    }
    return "".concat(headerParts.filter(function (item) {
      return item !== '';
    }).join('; '), ";");
  }

  /**
   * Mixes in a method to return just a plain object with no additional methods
   * @private
   * @param data - Any plain JSON response returned from the API
   * @return Enhanced object with toPlainObject method
   */
  function toPlainObject(data) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    return Object.defineProperty(data, 'toPlainObject', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: function value() {
        return copy$1(this);
      }
    });
  }

  /**
   * Handles errors received from the server. Parses the error into a more useful
   * format, places it in an exception and throws it.
   * See https://www.contentful.com/developers/docs/references/errors/
   * for more details on the data received on the errorResponse.data property
   * and the expected error codes.
   * @private
   */
  function errorHandler(errorResponse) {
    var config = errorResponse.config,
      response = errorResponse.response;
    var errorName;

    // Obscure the Management token
    if (config && config.headers && config.headers['Authorization']) {
      var token = "...".concat(config.headers['Authorization'].toString().substr(-5));
      config.headers['Authorization'] = "Bearer ".concat(token);
    }
    if (!isPlainObject$1(response) || !isPlainObject$1(config)) {
      throw errorResponse;
    }
    var data = response === null || response === void 0 ? void 0 : response.data;
    var errorData = {
      status: response === null || response === void 0 ? void 0 : response.status,
      statusText: response === null || response === void 0 ? void 0 : response.statusText,
      message: '',
      details: {}
    };
    if (config && isPlainObject$1(config)) {
      errorData.request = {
        url: config.url,
        headers: config.headers,
        method: config.method,
        payloadData: config.data
      };
    }
    if (data && _typeof$1(data) === 'object') {
      var _data$sys;
      if ('requestId' in data) {
        errorData.requestId = data.requestId || 'UNKNOWN';
      }
      if ('message' in data) {
        errorData.message = data.message || '';
      }
      if ('details' in data) {
        errorData.details = data.details || {};
      }
      errorName = (_data$sys = data.sys) === null || _data$sys === void 0 ? void 0 : _data$sys.id;
    }
    var error = new Error();
    error.name = errorName && errorName !== 'Unknown' ? errorName : "".concat(response === null || response === void 0 ? void 0 : response.status, " ").concat(response === null || response === void 0 ? void 0 : response.statusText);
    try {
      error.message = JSON.stringify(errorData, null, '  ');
    } catch (_unused) {
      var _errorData$message;
      error.message = (_errorData$message = errorData === null || errorData === void 0 ? void 0 : errorData.message) !== null && _errorData$message !== void 0 ? _errorData$message : '';
    }
    throw error;
  }

  /**
   * @param globalSettings - Global library settings
   * @returns getGlobalSettings - Method returning client settings
   * @category Client
   */
  function createGlobalOptions(globalSettings) {
    /**
     * Method merging pre-configured global options and provided local parameters
     * @param query - regular query object used for collection endpoints
     * @param query.environment - optional name of the environment
     * @param query.space - optional space ID
     * @param query.spaceBaseUrl - optional base URL for the space
     * @param query.environmentBaseUrl - optional base URL for the environment
     * @returns global options
     */
    return function getGlobalOptions(query) {
      return Object.assign({}, globalSettings, query);
    };
  }

  function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }
  function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
  function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
  var R = {
      0: 8203,
      1: 8204,
      2: 8205,
      3: 8290,
      4: 8291,
      5: 8288,
      6: 65279,
      7: 8289,
      8: 119155,
      9: 119156,
      a: 119157,
      b: 119158,
      c: 119159,
      d: 119160,
      e: 119161,
      f: 119162
    },
    b = {
      0: 8203,
      1: 8204,
      2: 8205,
      3: 65279
    },
    V = new Array(4).fill(String.fromCodePoint(b[0])).join("");
  function _(e) {
    var t = JSON.stringify(e);
    return "".concat(V).concat(Array.from(t).map(function (o) {
      var n = o.charCodeAt(0);
      if (n > 255) throw new Error("Only ASCII edit info can be encoded. Error attempting to encode ".concat(t, " on character ").concat(o, " (").concat(n, ")"));
      return Array.from(n.toString(4).padStart(4, "0")).map(function (r) {
        return String.fromCodePoint(b[r]);
      }).join("");
    }).join(""));
  }
  function D(e) {
    return !Number.isNaN(Number(e)) || /[a-z]/i.test(e) && !/\d+(?:[-:\/]\d+){2}(?:T\d+(?:[-:\/]\d+){1,2}(\.\d+)?Z?)?/.test(e) ? !1 : !!Date.parse(e);
  }
  function Q(e) {
    try {
      new URL(e, e.startsWith("/") ? "https://acme.com" : void 0);
    } catch (t) {
      return !1;
    }
    return !0;
  }
  function z(e, t) {
    var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "auto";
    return o === !0 || o === "auto" && (D(e) || Q(e)) ? e : "".concat(e).concat(_(t));
  }
  Object.fromEntries(Object.entries(b).map(function (e) {
      return e.reverse();
    }));
    Object.fromEntries(Object.entries(R).map(function (e) {
      return e.reverse();
    }));
    "".concat(Object.values(R).map(function (e) {
      return "\\u{".concat(e.toString(16), "}");
    }).join(""));
  function T(e, t) {
    return z(e, t);
  }
  var q = Object.prototype.hasOwnProperty,
    ee = Object.prototype.toString,
    te = function te(t, o, n) {
      if (ee.call(o) !== "[object Function]") throw new TypeError("iterator must be a function");
      var r = t.length;
      if (r === +r) for (var s = 0; s < r; s++) o.call(n, t[s], s, t);else for (var i in t) q.call(t, i) && o.call(n, t[i], i, t);
    },
    ne = te,
    y = a;
  function a(e, t, o) {
    if (arguments.length === 3) return a.set(e, t, o);
    if (arguments.length === 2) return a.get(e, t);
    var n = a.bind(a, e);
    for (var r in a) a.hasOwnProperty(r) && (n[r] = a[r].bind(n, e));
    return n;
  }
  a.get = function (t, o) {
    for (var n = Array.isArray(o) ? o : a.parse(o), r = 0; r < n.length; ++r) {
      var s = n[r];
      if (!(_typeof$3(t) == "object" && s in t)) throw new Error("Invalid reference token: " + s);
      t = t[s];
    }
    return t;
  };
  a.set = function (t, o, n) {
    var r = Array.isArray(o) ? o : a.parse(o),
      s = r[0];
    if (r.length === 0) throw Error("Can not set the root object");
    for (var i = 0; i < r.length - 1; ++i) {
      var c = r[i];
      typeof c != "string" && typeof c != "number" && (c = String(c)), !(c === "__proto__" || c === "constructor" || c === "prototype") && (c === "-" && Array.isArray(t) && (c = t.length), s = r[i + 1], c in t || (s.match(/^(\d+|-)$/) ? t[c] = [] : t[c] = {}), t = t[c]);
    }
    return s === "-" && Array.isArray(t) && (s = t.length), t[s] = n, this;
  };
  a.remove = function (e, t) {
    var o = Array.isArray(t) ? t : a.parse(t),
      n = o[o.length - 1];
    if (n === void 0) throw new Error('Invalid JSON pointer for remove: "' + t + '"');
    var r = a.get(e, o.slice(0, -1));
    if (Array.isArray(r)) {
      var s = +n;
      if (n === "" && isNaN(s)) throw new Error('Invalid array index: "' + n + '"');
      Array.prototype.splice.call(r, s, 1);
    } else delete r[n];
  };
  a.dict = function (t, o) {
    var n = {};
    return a.walk(t, function (r, s) {
      n[s] = r;
    }, o), n;
  };
  a.walk = function (t, o, n) {
    var r = [];
    n = n || function (s) {
      var i = Object.prototype.toString.call(s);
      return i === "[object Object]" || i === "[object Array]";
    }, function s(i) {
      ne(i, function (c, u) {
        r.push(String(u)), n(c) ? s(c) : o(c, a.compile(r)), r.pop();
      });
    }(t);
  };
  a.has = function (t, o) {
    try {
      a.get(t, o);
    } catch (n) {
      return !1;
    }
    return !0;
  };
  a.escape = function (t) {
    return t.toString().replace(/~/g, "~0").replace(/\//g, "~1");
  };
  a.unescape = function (t) {
    return t.replace(/~1/g, "/").replace(/~0/g, "~");
  };
  a.parse = function (t) {
    if (t === "") return [];
    if (t.charAt(0) !== "/") throw new Error("Invalid JSON pointer: " + t);
    return t.substring(1).split(/\//).map(a.unescape);
  };
  a.compile = function (t) {
    return t.length === 0 ? "" : "/" + t.map(a.escape).join("/");
  };
  var re = function re(_ref) {
      var e = _ref.pointer,
        t = _ref.mappings,
        o = _ref.data,
        n = _ref.hiddenStrings;
      var r = t[e];
      delete t[e];
      var s = _F(o, e);
      var _iterator = _createForOfIteratorHelper(s),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var i = _step.value;
          t[i] = r;
          var c = y.get(o, i),
            u = T(c, n);
          y.set(o, i, u);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    },
    _F = function F(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      var o = [],
        n = y.get(e, t);
      if (n.content) for (var r = 0; r < n.content.length; r++) n.content[r].nodeType === "text" ? o.push("".concat(t, "/content/").concat(r, "/value")) : o.push.apply(o, _toConsumableArray$1(_F(e, "".concat(t, "/content/").concat(r))));
      return o;
    },
    x = function x(_ref2) {
      var e = _ref2.entityId,
        t = _ref2.entityType,
        o = _ref2.space,
        n = _ref2.environment,
        r = _ref2.field,
        s = _ref2.locale,
        i = _ref2.editorInterface,
        c = _ref2.fieldType,
        u = _ref2.targetOrigin,
        f = _ref2.platform;
      var d = {
        origin: "contentful.com",
        href: "".concat("".concat(u || "https://app.contentful.com", "/spaces/").concat(o, "/environments/").concat(n), "/", t === "Entry" ? "entries" : "assets", "/").concat(e, "/?focusedField=").concat(r, "&focusedLocale=").concat(s, "&source=vercel-content-link"),
        contentful: {
          editorInterface: i,
          fieldType: c
        }
      };
      return f === "vercel" && delete d.contentful, d;
    },
    W = function W(e) {
      return ["builtin", "sidebar-builtin", "editor-builtin"].includes(e);
    },
    U = function U(e) {
      return oe.includes(e);
    };
  function j(e) {
    if (typeof structuredClone == "function") return structuredClone(e);
    try {
      return JSON.parse(JSON.stringify(e));
    } catch (t) {
      return console.warn("Failed to clone data:", e, t), e;
    }
  }
  var oe = ["singleLine", "tagEditor", "listInput", "checkbox", "richTextEditor", "multipleLine"];
  function C(e, t, o, n, r, s, i) {
    var c = i ? t[i] : t;
    switch (e) {
      case "Symbol":
        {
          var u = T(c, o);
          y.set(n, r, u);
          break;
        }
      case "Text":
        {
          var _u = T(c, o);
          y.set(n, r, _u);
          break;
        }
      case "RichText":
        {
          re({
            pointer: "",
            mappings: s,
            data: c,
            hiddenStrings: o
          });
          break;
        }
      case "Array":
        {
          var _u2 = c.map(function (f) {
            return typeof f == "string" ? T(f, o) : f;
          });
          y.set(n, r, _u2);
          break;
        }
    }
  }
  var $ = function $(e, t, o, n, r) {
      if (!e.fields) return;
      var s = e.sys.contentSourceMaps;
      if (!s) {
        console.error("Content source maps data is missing");
        return;
      }
      var i = s.mappings;
      var _loop = function _loop() {
          var u = i[c].source,
            f = e.sys.space.sys.id,
            p = e.sys.environment.sys.id,
            g = e.sys.id,
            v = e.sys.type,
            h = t[u.fieldType],
            d = o[u.editorInterface];
          if (W(d.widgetNamespace) && !U(d.widgetId)) return 0; // continue
          var l = c.startsWith("/") ? c : "/".concat(c);
          if (y.has(e, l)) {
            var m = y.get(e, l);
            if (m === null) return {
              v: void 0
            };
            var S = l.split("/").pop();
            if (!S) {
              console.error("Field name could not be extracted from the pointer", l);
              return {
                v: void 0
              };
            }
            var A = e.sys.locale;
            if (A) {
              var E = x({
                entityId: g,
                entityType: v,
                space: f,
                environment: p,
                field: S,
                locale: A,
                editorInterface: d,
                fieldType: h,
                targetOrigin: n,
                platform: r
              });
              C(h, m, E, e, l, i);
            } else Object.keys(m).forEach(function (w) {
              var I = x({
                entityId: g,
                entityType: v,
                space: f,
                environment: p,
                field: S,
                locale: w,
                editorInterface: d,
                fieldType: h,
                targetOrigin: n,
                platform: r
              });
              C(h, m, I, e, "".concat(l, "/").concat(w), i, w);
            });
          }
        },
        _ret;
      for (var c in i) {
        _ret = _loop();
        if (_ret === 0) continue;
        if (_ret) return _ret.v;
      }
    },
    ue = function ue(e, t, o) {
      var r;
      var n = j(e);
      if (n.sys && "items" in n) {
        var s = n;
        if (!((r = s.sys) != null && r.contentSourceMapsLookup)) return console.error("Content source maps lookup data is missing"), s;
        var _s$sys$contentSourceM = s.sys.contentSourceMapsLookup,
          i = _s$sys$contentSourceM.fieldTypes,
          c = _s$sys$contentSourceM.editorInterfaces,
          u = s.items,
          f = s.includes;
        u.forEach(function (p) {
          return $(p, i, c, t, o);
        }), f && f.Entry && f.Entry.forEach(function (p) {
          return $(p, i, c, t, o);
        }), f && f.Asset && f.Asset.forEach(function (p) {
          return $(p, i, c, t, o);
        });
      } else {
        var _s = n;
        if (!_s.sys.contentSourceMapsLookup) return console.error("Content source maps lookup data is missing"), _s;
        $(_s, _s.sys.contentSourceMapsLookup.fieldTypes, _s.sys.contentSourceMapsLookup.editorInterfaces, t, o);
      }
      return n;
    };

  var fastCopy = {exports: {}};

  (function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    })(this, function () {

      var toStringFunction = Function.prototype.toString;
      var create = Object.create,
        defineProperty = Object.defineProperty,
        getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
        getOwnPropertyNames = Object.getOwnPropertyNames,
        getOwnPropertySymbols = Object.getOwnPropertySymbols,
        getPrototypeOf$1 = Object.getPrototypeOf;
      var _a = Object.prototype,
        hasOwnProperty = _a.hasOwnProperty,
        propertyIsEnumerable = _a.propertyIsEnumerable;
      var SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';
      var WEAK_MAP = typeof WeakMap === 'function';
      /**
       * @function createCache
       *
       * @description
       * get a new cache object to prevent circular references
       *
       * @returns the new cache object
       */
      var createCache = function () {
        if (WEAK_MAP) {
          return function () {
            return new WeakMap();
          };
        }
        var Cache = /** @class */function () {
          function Cache() {
            this._keys = [];
            this._values = [];
          }
          Cache.prototype.has = function (key) {
            return !!~this._keys.indexOf(key);
          };
          Cache.prototype.get = function (key) {
            return this._values[this._keys.indexOf(key)];
          };
          Cache.prototype.set = function (key, value) {
            this._keys.push(key);
            this._values.push(value);
          };
          return Cache;
        }();
        return function () {
          return new Cache();
        };
      }();
      /**
       * @function getCleanClone
       *
       * @description
       * get an empty version of the object with the same prototype it has
       *
       * @param object the object to build a clean clone from
       * @param realm the realm the object resides in
       * @returns the empty cloned object
       */
      var getCleanClone = function getCleanClone(object, realm) {
        var prototype = object.__proto__ || getPrototypeOf$1(object);
        if (!prototype) {
          return create(null);
        }
        var Constructor = prototype.constructor;
        if (Constructor === realm.Object) {
          return prototype === realm.Object.prototype ? {} : create(prototype);
        }
        if (~toStringFunction.call(Constructor).indexOf('[native code]')) {
          try {
            return new Constructor();
          } catch (_a) {}
        }
        return create(prototype);
      };
      /**
       * @function getObjectCloneLoose
       *
       * @description
       * get a copy of the object based on loose rules, meaning all enumerable keys
       * and symbols are copied, but property descriptors are not considered
       *
       * @param object the object to clone
       * @param realm the realm the object resides in
       * @param handleCopy the function that handles copying the object
       * @returns the copied object
       */
      var getObjectCloneLoose = function getObjectCloneLoose(object, realm, handleCopy, cache) {
        var clone = getCleanClone(object, realm);
        // set in the cache immediately to be able to reuse the object recursively
        cache.set(object, clone);
        for (var key in object) {
          if (hasOwnProperty.call(object, key)) {
            clone[key] = handleCopy(object[key], cache);
          }
        }
        if (SYMBOL_PROPERTIES) {
          var symbols = getOwnPropertySymbols(object);
          for (var index = 0, length_1 = symbols.length, symbol = void 0; index < length_1; ++index) {
            symbol = symbols[index];
            if (propertyIsEnumerable.call(object, symbol)) {
              clone[symbol] = handleCopy(object[symbol], cache);
            }
          }
        }
        return clone;
      };
      /**
       * @function getObjectCloneStrict
       *
       * @description
       * get a copy of the object based on strict rules, meaning all keys and symbols
       * are copied based on the original property descriptors
       *
       * @param object the object to clone
       * @param realm the realm the object resides in
       * @param handleCopy the function that handles copying the object
       * @returns the copied object
       */
      var getObjectCloneStrict = function getObjectCloneStrict(object, realm, handleCopy, cache) {
        var clone = getCleanClone(object, realm);
        // set in the cache immediately to be able to reuse the object recursively
        cache.set(object, clone);
        var properties = SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);
        for (var index = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index < length_2; ++index) {
          property = properties[index];
          if (property !== 'callee' && property !== 'caller') {
            descriptor = getOwnPropertyDescriptor(object, property);
            if (descriptor) {
              // Only clone the value if actually a value, not a getter / setter.
              if (!descriptor.get && !descriptor.set) {
                descriptor.value = handleCopy(object[property], cache);
              }
              try {
                defineProperty(clone, property, descriptor);
              } catch (error) {
                // Tee above can fail on node in edge cases, so fall back to the loose assignment.
                clone[property] = descriptor.value;
              }
            } else {
              // In extra edge cases where the property descriptor cannot be retrived, fall back to
              // the loose assignment.
              clone[property] = handleCopy(object[property], cache);
            }
          }
        }
        return clone;
      };
      /**
       * @function getRegExpFlags
       *
       * @description
       * get the flags to apply to the copied regexp
       *
       * @param regExp the regexp to get the flags of
       * @returns the flags for the regexp
       */
      var getRegExpFlags = function getRegExpFlags(regExp) {
        var flags = '';
        if (regExp.global) {
          flags += 'g';
        }
        if (regExp.ignoreCase) {
          flags += 'i';
        }
        if (regExp.multiline) {
          flags += 'm';
        }
        if (regExp.unicode) {
          flags += 'u';
        }
        if (regExp.sticky) {
          flags += 'y';
        }
        return flags;
      };

      // utils
      var isArray = Array.isArray;
      var getPrototypeOf = Object.getPrototypeOf;
      var GLOBAL_THIS = function () {
        if (typeof globalThis !== 'undefined') {
          return globalThis;
        }
        if (typeof self !== 'undefined') {
          return self;
        }
        if (typeof window !== 'undefined') {
          return window;
        }
        if (typeof global !== 'undefined') {
          return global;
        }
        if (console && console.error) {
          console.error('Unable to locate global object, returning "this".');
        }
        return this;
      }();
      /**
       * @function copy
       *
       * @description
       * copy an value deeply as much as possible
       *
       * If `strict` is applied, then all properties (including non-enumerable ones)
       * are copied with their original property descriptors on both objects and arrays.
       *
       * The value is compared to the global constructors in the `realm` provided,
       * and the native constructor is always used to ensure that extensions of native
       * objects (allows in ES2015+) are maintained.
       *
       * @param value the value to copy
       * @param [options] the options for copying with
       * @param [options.isStrict] should the copy be strict
       * @param [options.realm] the realm (this) value the value is copied from
       * @returns the copied value
       */
      function copy(value, options) {
        // manually coalesced instead of default parameters for performance
        var isStrict = !!(options && options.isStrict);
        var realm = options && options.realm || GLOBAL_THIS;
        var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;
        /**
         * @function handleCopy
         *
         * @description
         * copy the value recursively based on its type
         *
         * @param value the value to copy
         * @returns the copied value
         */
        var _handleCopy = function handleCopy(value, cache) {
          if (!value || _typeof$3(value) !== 'object') {
            return value;
          }
          if (cache.has(value)) {
            return cache.get(value);
          }
          var prototype = value.__proto__ || getPrototypeOf(value);
          var Constructor = prototype && prototype.constructor;
          // plain objects
          if (!Constructor || Constructor === realm.Object) {
            return getObjectClone(value, realm, _handleCopy, cache);
          }
          var clone;
          // arrays
          if (isArray(value)) {
            // if strict, include non-standard properties
            if (isStrict) {
              return getObjectCloneStrict(value, realm, _handleCopy, cache);
            }
            clone = new Constructor();
            cache.set(value, clone);
            for (var index = 0, length_1 = value.length; index < length_1; ++index) {
              clone[index] = _handleCopy(value[index], cache);
            }
            return clone;
          }
          // dates
          if (value instanceof realm.Date) {
            return new Constructor(value.getTime());
          }
          // regexps
          if (value instanceof realm.RegExp) {
            clone = new Constructor(value.source, value.flags || getRegExpFlags(value));
            clone.lastIndex = value.lastIndex;
            return clone;
          }
          // maps
          if (realm.Map && value instanceof realm.Map) {
            clone = new Constructor();
            cache.set(value, clone);
            value.forEach(function (value, key) {
              clone.set(key, _handleCopy(value, cache));
            });
            return clone;
          }
          // sets
          if (realm.Set && value instanceof realm.Set) {
            clone = new Constructor();
            cache.set(value, clone);
            value.forEach(function (value) {
              clone.add(_handleCopy(value, cache));
            });
            return clone;
          }
          // blobs
          if (realm.Blob && value instanceof realm.Blob) {
            return value.slice(0, value.size, value.type);
          }
          // buffers (node-only)
          if (realm.Buffer && realm.Buffer.isBuffer(value)) {
            clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(value.length) : new Constructor(value.length);
            cache.set(value, clone);
            value.copy(clone);
            return clone;
          }
          // arraybuffers / dataviews
          if (realm.ArrayBuffer) {
            // dataviews
            if (realm.ArrayBuffer.isView(value)) {
              clone = new Constructor(value.buffer.slice(0));
              cache.set(value, clone);
              return clone;
            }
            // arraybuffers
            if (value instanceof realm.ArrayBuffer) {
              clone = value.slice(0);
              cache.set(value, clone);
              return clone;
            }
          }
          // if the value cannot / should not be cloned, don't
          if (
          // promise-like
          typeof value.then === 'function' ||
          // errors
          value instanceof Error ||
          // weakmaps
          realm.WeakMap && value instanceof realm.WeakMap ||
          // weaksets
          realm.WeakSet && value instanceof realm.WeakSet) {
            return value;
          }
          // assume anything left is a custom constructor
          return getObjectClone(value, realm, _handleCopy, cache);
        };
        return _handleCopy(value, createCache());
      }
      // Adding reference to allow usage in CommonJS libraries compiled using TSC, which
      // expects there to be a default property on the exported value. See
      // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.
      copy.default = copy;
      /**
       * @function strictCopy
       *
       * @description
       * copy the value with `strict` option pre-applied
       *
       * @param value the value to copy
       * @param [options] the options for copying with
       * @param [options.realm] the realm (this) value the value is copied from
       * @returns the copied value
       */
      copy.strict = function strictCopy(value, options) {
        return copy(value, {
          isStrict: true,
          realm: options ? options.realm : void 0
        });
      };
      return copy;
    });
  })(fastCopy);
  var fastCopyExports = fastCopy.exports;
  var copy = /*@__PURE__*/getDefaultExportFromCjs(fastCopyExports);

  var _typeof = typeof Symbol === "function" && _typeof$3(Symbol.iterator) === "symbol" ? function (obj) {
    return _typeof$3(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof$3(obj);
  };
  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  var UNRESOLVED_LINK = {}; // unique object to avoid polyfill bloat using Symbol()

  /**
   * isLink Function
   * Checks if the object has sys.type "Link"
   * @param object
   */
  var isLink = function isLink(object) {
    return object && object.sys && object.sys.type === 'Link';
  };

  /**
   * isResourceLink Function
   * Checks if the object has sys.type "ResourceLink"
   * @param object
   */
  var isResourceLink = function isResourceLink(object) {
    return object && object.sys && object.sys.type === 'ResourceLink';
  };

  /**
   * Creates a key with spaceId and a key without for entityMap
   *
   * @param {*} sys
   * @param {String} sys.type
   * @param {String} sys.id
   * @param {*} sys.space
   * @param {*} sys.space.sys
   * @param {String} sys.space.id
   * @return {string[]}
   */
  var makeEntityMapKeys = function makeEntityMapKeys(sys) {
    if (sys.space && sys.environment) {
      return [sys.type + '!' + sys.id, sys.space.sys.id + '!' + sys.environment.sys.id + '!' + sys.type + '!' + sys.id];
    }
    return [sys.type + '!' + sys.id];
  };

  /**
   * Looks up in entityMap
   *
   * @param entityMap
   * @param {*} linkData
   * @param {String} linkData.type
   * @param {String} linkData.linkType
   * @param {String} linkData.id
   * @param {String} linkData.urn
   * @return {String}
   */
  var lookupInEntityMap = function lookupInEntityMap(entityMap, linkData) {
    var entryId = linkData.entryId,
      linkType = linkData.linkType,
      spaceId = linkData.spaceId,
      environmentId = linkData.environmentId;
    if (spaceId && environmentId) {
      return entityMap.get(spaceId + '!' + environmentId + '!' + linkType + '!' + entryId);
    }
    return entityMap.get(linkType + '!' + entryId);
  };
  var getIdsFromUrn = function getIdsFromUrn(urn) {
    var regExp = /.*:spaces\/([^/]+)(?:\/environments\/([^/]+))?\/entries\/([^/]+)$/;
    if (!regExp.test(urn)) {
      return undefined;
    }
    var _urn$match = urn.match(regExp),
      _urn$match2 = _slicedToArray(_urn$match, 4);
      _urn$match2[0];
      var spaceId = _urn$match2[1],
      _urn$match2$ = _urn$match2[2],
      environmentId = _urn$match2$ === undefined ? 'master' : _urn$match2$,
      entryId = _urn$match2[3];
    return {
      spaceId: spaceId,
      environmentId: environmentId,
      entryId: entryId
    };
  };

  /**
   * getResolvedLink Function
   *
   * @param entityMap
   * @param link
   * @return {undefined}
   */
  var getResolvedLink = function getResolvedLink(entityMap, link) {
    var _link$sys = link.sys,
      type = _link$sys.type,
      linkType = _link$sys.linkType;
    if (type === 'ResourceLink') {
      if (!linkType.startsWith('Contentful:')) {
        return link;
      }
      var urn = link.sys.urn;
      var _getIdsFromUrn = getIdsFromUrn(urn),
        spaceId = _getIdsFromUrn.spaceId,
        environmentId = _getIdsFromUrn.environmentId,
        _entryId = _getIdsFromUrn.entryId;
      var extractedLinkType = linkType.split(':')[1];
      return lookupInEntityMap(entityMap, {
        linkType: extractedLinkType,
        entryId: _entryId,
        spaceId: spaceId,
        environmentId: environmentId
      }) || UNRESOLVED_LINK;
    }
    var entryId = link.sys.id;
    return lookupInEntityMap(entityMap, {
      linkType: linkType,
      entryId: entryId
    }) || UNRESOLVED_LINK;
  };

  /**
   * cleanUpLinks Function
   * - Removes unresolvable links from Arrays and Objects
   *
   * @param {Object[]|Object} input
   */
  var cleanUpLinks = function cleanUpLinks(input) {
    if (Array.isArray(input)) {
      return input.filter(function (val) {
        return val !== UNRESOLVED_LINK;
      });
    }
    for (var key in input) {
      if (input[key] === UNRESOLVED_LINK) {
        delete input[key];
      }
    }
    return input;
  };

  /**
   * walkMutate Function
   * @param input
   * @param predicate
   * @param mutator
   * @param removeUnresolved
   * @return {*}
   */
  var walkMutate = function walkMutate(input, predicate, mutator, removeUnresolved) {
    if (predicate(input)) {
      return mutator(input);
    }
    if (input && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {
      for (var key in input) {
        // eslint-disable-next-line no-prototype-builtins
        if (input.hasOwnProperty(key)) {
          input[key] = walkMutate(input[key], predicate, mutator, removeUnresolved);
        }
      }
      if (removeUnresolved) {
        input = cleanUpLinks(input);
      }
    }
    return input;
  };
  var normalizeLink = function normalizeLink(entityMap, link, removeUnresolved) {
    var resolvedLink = getResolvedLink(entityMap, link);
    if (resolvedLink === UNRESOLVED_LINK) {
      return removeUnresolved ? resolvedLink : link;
    }
    return resolvedLink;
  };
  var makeEntryObject = function makeEntryObject(item, itemEntryPoints) {
    if (!Array.isArray(itemEntryPoints)) {
      return item;
    }
    var entryPoints = Object.keys(item).filter(function (ownKey) {
      return itemEntryPoints.indexOf(ownKey) !== -1;
    });
    return entryPoints.reduce(function (entryObj, entryPoint) {
      entryObj[entryPoint] = item[entryPoint];
      return entryObj;
    }, {});
  };

  /**
   * resolveResponse Function
   * Resolves contentful response to normalized form.
   * @param {Object} response Contentful response
   * @param {{removeUnresolved: Boolean, itemEntryPoints: Array<String>}|{}} options
   * @param {Boolean} options.removeUnresolved - Remove unresolved links default:false
   * @param {Array<String>} options.itemEntryPoints - Resolve links only in those item properties
   * @return {Object}
   */
  var resolveResponse = function resolveResponse(response, options) {
    options = options || {};
    if (!response.items) {
      return [];
    }
    var responseClone = copy(response);
    var allIncludes = Object.keys(responseClone.includes || {}).reduce(function (all, type) {
      return [].concat(_toConsumableArray(all), _toConsumableArray(response.includes[type]));
    }, []);
    var allEntries = [].concat(_toConsumableArray(responseClone.items), _toConsumableArray(allIncludes)).filter(function (entity) {
      return Boolean(entity.sys);
    });
    var entityMap = new Map(allEntries.reduce(function (acc, entity) {
      var entries = makeEntityMapKeys(entity.sys).map(function (key) {
        return [key, entity];
      });
      acc.push.apply(acc, _toConsumableArray(entries));
      return acc;
    }, []));
    allEntries.forEach(function (item) {
      var entryObject = makeEntryObject(item, options.itemEntryPoints);
      Object.assign(item, walkMutate(entryObject, function (x) {
        return isLink(x) || isResourceLink(x);
      }, function (link) {
        return normalizeLink(entityMap, link, options.removeUnresolved);
      }, options.removeUnresolved));
    });
    return responseClone.items;
  };

  var stringify = {exports: {}};

  (function (module, exports) {
    exports = module.exports = stringify;
    exports.getSerialize = serializer;
    function stringify(obj, replacer, spaces, cycleReplacer) {
      return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
    }
    function serializer(replacer, cycleReplacer) {
      var stack = [],
        keys = [];
      if (cycleReplacer == null) cycleReplacer = function cycleReplacer(key, value) {
        if (stack[0] === value) return "[Circular ~]";
        return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
      };
      return function (key, value) {
        if (stack.length > 0) {
          var thisPos = stack.indexOf(this);
          ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
          ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
          if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
        } else stack.push(value);
        return replacer == null ? value : replacer.call(this, key, value);
      };
    }
  })(stringify, stringify.exports);
  var stringifyExports = stringify.exports;
  var jsonStringifySafe = /*@__PURE__*/getDefaultExportFromCjs(stringifyExports);

  function mixinStringifySafe(data) {
    return Object.defineProperty(data, 'stringifySafe', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: function value() {
        var serializer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
        return jsonStringifySafe(this, serializer, indent, function (key, value) {
          return {
            sys: {
              type: 'Link',
              linkType: 'Entry',
              id: value.sys.id,
              circular: true
            }
          };
        });
      }
    });
  }

  /**
   * Retrieves all the available pages for a sync operation
   */
  function pagedSync(_x, _x2, _x3) {
    return _pagedSync.apply(this, arguments);
  }
  /**
   * @private
   * @param items
   * @returns Entities mapped to an object for each entity type
   */
  function _pagedSync() {
    _pagedSync = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee(http, query, options) {
      var defaultOptions, _Object$assign, withoutLinkResolution, withoutUnresolvableLinks, paginate, response, mappedResponseItems;
      return _regeneratorRuntime$1.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!(!query || !query.initial && !query.nextSyncToken && !query.nextPageToken)) {
              _context.next = 2;
              break;
            }
            throw new Error('Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing');
          case 2:
            if (!(query['content_type'] && !query.type)) {
              _context.next = 6;
              break;
            }
            query.type = 'Entry';
            _context.next = 8;
            break;
          case 6:
            if (!(query['content_type'] && query.type && query.type !== 'Entry')) {
              _context.next = 8;
              break;
            }
            throw new Error('When using the `content_type` filter your `type` parameter cannot be different from `Entry`.');
          case 8:
            defaultOptions = {
              withoutLinkResolution: false,
              withoutUnresolvableLinks: false,
              paginate: true
            };
            _Object$assign = Object.assign(Object.assign({}, defaultOptions), options), withoutLinkResolution = _Object$assign.withoutLinkResolution, withoutUnresolvableLinks = _Object$assign.withoutUnresolvableLinks, paginate = _Object$assign.paginate;
            _context.next = 12;
            return getSyncPage(http, [], query, {
              paginate: paginate
            });
          case 12:
            response = _context.sent;
            // clones response.items used in includes because we don't want these to be mutated
            if (!withoutLinkResolution) {
              response.items = resolveResponse(response, {
                removeUnresolved: withoutUnresolvableLinks,
                itemEntryPoints: ['fields']
              });
            }
            // maps response items again after getters are attached
            mappedResponseItems = mapResponseItems(response.items);
            if (response.nextSyncToken) {
              mappedResponseItems.nextSyncToken = response.nextSyncToken;
            }
            if (response.nextPageToken) {
              mappedResponseItems.nextPageToken = response.nextPageToken;
            }
            return _context.abrupt("return", freezeSys(mixinStringifySafe(toPlainObject(mappedResponseItems))));
          case 18:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return _pagedSync.apply(this, arguments);
  }
  function mapResponseItems(items) {
    var reducer = function reducer(type) {
      return function (accumulated, item) {
        if (item.sys.type === type) {
          accumulated.push(toPlainObject(item));
        }
        return accumulated;
      };
    };
    return {
      entries: items.reduce(reducer('Entry'), []),
      assets: items.reduce(reducer('Asset'), []),
      deletedEntries: items.reduce(reducer('DeletedEntry'), []),
      deletedAssets: items.reduce(reducer('DeletedAsset'), [])
    };
  }
  function createRequestQuery(originalQuery) {
    if (originalQuery.nextPageToken) {
      return {
        sync_token: originalQuery.nextPageToken
      };
    }
    if (originalQuery.nextSyncToken) {
      return {
        sync_token: originalQuery.nextSyncToken
      };
    }
    if (originalQuery.sync_token) {
      return {
        sync_token: originalQuery.sync_token
      };
    }
    return originalQuery;
  }
  /**
   * If the response contains a nextPageUrl, extracts the sync token to get the
   * next page and calls itself again with that token.
   * Otherwise, if the response contains a nextSyncUrl, extracts the sync token
   * and returns it.
   * On each call of this function, any retrieved items are collected in the
   * supplied items array, which gets returned in the end.
   */
  function getSyncPage(_x4, _x5, _x6, _x7) {
    return _getSyncPage.apply(this, arguments);
  }
  /**
   * Extracts token out of an url
   * @private
   */
  function _getSyncPage() {
    _getSyncPage = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee2(http, items, query, _ref) {
      var paginate, requestQuery, response, data;
      return _regeneratorRuntime$1.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            paginate = _ref.paginate;
            requestQuery = createRequestQuery(query);
            _context2.next = 4;
            return http.get('sync', createRequestConfig({
              query: requestQuery
            }));
          case 4:
            response = _context2.sent;
            data = response.data || {};
            items = items.concat(data.items || []);
            if (!data.nextPageUrl) {
              _context2.next = 15;
              break;
            }
            if (!paginate) {
              _context2.next = 12;
              break;
            }
            delete requestQuery.initial;
            requestQuery.sync_token = getToken(data.nextPageUrl);
            return _context2.abrupt("return", getSyncPage(http, items, requestQuery, {
              paginate: paginate
            }));
          case 12:
            return _context2.abrupt("return", {
              items: items,
              nextPageToken: getToken(data.nextPageUrl)
            });
          case 15:
            if (!data.nextSyncUrl) {
              _context2.next = 19;
              break;
            }
            return _context2.abrupt("return", {
              items: items,
              nextSyncToken: getToken(data.nextSyncUrl)
            });
          case 19:
            return _context2.abrupt("return", {
              items: []
            });
          case 20:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return _getSyncPage.apply(this, arguments);
  }
  function getToken(url) {
    var urlParts = url.split('?');
    return urlParts.length > 0 ? urlParts[1].replace('sync_token=', '') : '';
  }

  function normalizeSearchParameters(query) {
    var convertedQuery = {};
    var hasConverted = false;
    for (var key in query) {
      // We allow multiple values to be passed as arrays
      // which have to be converted to comma-separated strings before being sent to the API
      if (Array.isArray(query[key])) {
        convertedQuery[key] = query[key].join(',');
        hasConverted = true;
      }
    }
    if (hasConverted) {
      return Object.assign(Object.assign({}, query), convertedQuery);
    }
    return query;
  }

  function getQuerySelectionSet(query) {
    if (!query.select) {
      return new Set();
    }
    // The selection of fields for the query is limited
    // Get the different parts that are listed for selection
    var allSelects = Array.isArray(query.select) ? query.select : query.select.split(',').map(function (q) {
      return q.trim();
    });
    // Move the parts into a set for easy access and deduplication
    return new Set(allSelects);
  }

  /*
   * sdk relies heavily on sys metadata
   * so we cannot omit the sys property on sdk level entirely
   * and we have to ensure that at least `id` and `type` are present
   * */
  function normalizeSelect(query) {
    if (!query.select) {
      return query;
    }
    var selectedSet = getQuerySelectionSet(query);
    // If we already select all of `sys` we can just return
    // since we're anyway fetching everything that is needed
    if (selectedSet.has('sys')) {
      return query;
    }
    // We don't select `sys` so we need to ensure the minimum set
    selectedSet.add('sys.id');
    selectedSet.add('sys.type');
    // Reassign the normalized sys properties
    return Object.assign(Object.assign({}, query), {
      select: _toConsumableArray$1(selectedSet).join(',')
    });
  }

  function resolveCircular(data, _ref) {
    var resolveLinks = _ref.resolveLinks,
      removeUnresolved = _ref.removeUnresolved;
    var wrappedData = mixinStringifySafe(data);
    if (resolveLinks) {
      wrappedData.items = resolveResponse(wrappedData, {
        removeUnresolved: removeUnresolved,
        itemEntryPoints: ['fields']
      });
    }
    return wrappedData;
  }

  function _callSuper$1(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct$1() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct$1() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct$1 = function _isNativeReflectConstruct() { return !!t; })(); }
  var ValidationError = /*#__PURE__*/function (_Error) {
    function ValidationError(name, message) {
      var _this;
      _classCallCheck(this, ValidationError);
      _this = _callSuper$1(this, ValidationError, ["Invalid \"".concat(name, "\" provided, ") + message]);
      _this.name = 'ValidationError';
      return _this;
    }
    _inherits$1(ValidationError, _Error);
    return _createClass(ValidationError);
  }(/*#__PURE__*/_wrapNativeSuper(Error));

  function validateTimestamp(name, timestamp, options) {
    options = options || {};
    if (typeof timestamp !== 'number') {
      throw new ValidationError(name, "only numeric values are allowed for timestamps, provided type was \"".concat(_typeof$3(timestamp), "\""));
    }
    if (options.maximum && timestamp > options.maximum) {
      throw new ValidationError(name, "value (".concat(timestamp, ") cannot be further in the future than expected maximum (").concat(options.maximum, ")"));
    }
    if (options.now && timestamp < options.now) {
      throw new ValidationError(name, "value (".concat(timestamp, ") cannot be in the past, current time was ").concat(options.now));
    }
  }

  function checkLocaleParamIsAll(query) {
    if (query.locale === '*') {
      throw new ValidationError('locale', "The use of locale='*' is no longer supported.To fetch an entry in all existing locales,\n      use client.withAllLocales instead of the locale='*' parameter.");
    }
  }
  function checkLocaleParamExists(query) {
    if (query.locale) {
      throw new ValidationError('locale', 'The `locale` parameter is not allowed');
    }
  }
  function validateLocaleParam(query, isWithAllLocalesClient) {
    if (isWithAllLocalesClient) {
      checkLocaleParamExists(query);
    } else {
      checkLocaleParamIsAll(query);
    }
    return;
  }
  function validateResolveLinksParam(query) {
    if ('resolveLinks' in query) {
      throw new ValidationError('resolveLinks', "The use of the 'resolveLinks' parameter is no longer supported. By default, links are resolved.\n      If you do not want to resolve links, use client.withoutLinkResolution.");
    }
    return;
  }
  function validateRemoveUnresolvedParam(query) {
    if ('removeUnresolved' in query) {
      throw new ValidationError('removeUnresolved', "The use of the 'removeUnresolved' parameter is no longer supported. By default, unresolved links are kept as link objects.\n      If you do not want to include unresolved links, use client.withoutUnresolvableLinks.");
    }
    return;
  }
  function checkIncludeContentSourceMapsParamIsAllowed(host, includeContentSourceMaps) {
    if (includeContentSourceMaps === undefined) {
      return false;
    }
    if (typeof includeContentSourceMaps !== 'boolean') {
      throw new ValidationError('includeContentSourceMaps', "The 'includeContentSourceMaps' parameter must be a boolean.");
    }
    var includeContentSourceMapsIsAllowed = host === 'preview.contentful.com';
    if (includeContentSourceMaps && !includeContentSourceMapsIsAllowed) {
      throw new ValidationError('includeContentSourceMaps', "The 'includeContentSourceMaps' parameter can only be used with the CPA. Please set host to 'preview.contentful.com' to include Content Source Maps.\n      ");
    }
    return includeContentSourceMaps;
  }

  function validateSearchParameters(query) {
    for (var key in query) {
      var value = query[key];
      // We don’t allow any objects as values for query parameters
      if (_typeof$3(value) === 'object' && value !== null && !Array.isArray(value)) {
        throw new Error("Objects are not supported as value for the \"".concat(key, "\" query parameter."));
      }
    }
  }

  function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  var ASSET_KEY_MAX_LIFETIME = 48 * 60 * 60;
  var NotFoundError = /*#__PURE__*/function (_Error) {
    function NotFoundError(id, environment, space) {
      var _this;
      _classCallCheck(this, NotFoundError);
      _this = _callSuper(this, NotFoundError, ['The resource could not be found.']);
      _this.sys = {
        type: 'Error',
        id: 'NotFound'
      };
      _this.details = {
        type: 'Entry',
        id: id,
        environment: environment,
        space: space
      };
      return _this;
    }
    _inherits$1(NotFoundError, _Error);
    return _createClass(NotFoundError);
  }(/*#__PURE__*/_wrapNativeSuper(Error));
  function createContentfulApi(_ref, options) {
    var http = _ref.http,
      getGlobalOptions = _ref.getGlobalOptions;
    var notFoundError = function notFoundError() {
      var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'unknown';
      return new NotFoundError(id, getGlobalOptions().environment, getGlobalOptions().space);
    };
    var getBaseUrl = function getBaseUrl(context) {
      var baseUrl = context === 'space' ? getGlobalOptions().spaceBaseUrl : getGlobalOptions().environmentBaseUrl;
      if (!baseUrl) {
        throw new Error('Please define baseUrl for ' + context);
      }
      if (!baseUrl.endsWith('/')) {
        baseUrl += '/';
      }
      return baseUrl;
    };
    function maybeEnableSourceMaps() {
      var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _a, _b;
      var params = http.httpClientParams;
      var includeContentSourceMaps = (_a = params === null || params === void 0 ? void 0 : params.includeContentSourceMaps) !== null && _a !== void 0 ? _a : (_b = params === null || params === void 0 ? void 0 : params.alphaFeatures) === null || _b === void 0 ? void 0 : _b.includeContentSourceMaps;
      var host = params === null || params === void 0 ? void 0 : params.host;
      var areAllowed = checkIncludeContentSourceMapsParamIsAllowed(host, includeContentSourceMaps);
      if (areAllowed) {
        query.includeContentSourceMaps = true;
        // Ensure that content source maps and required attributes are selected
        if (query.select) {
          var selection = getQuerySelectionSet(query);
          selection.add('sys');
          query.select = Array.from(selection).join(',');
        }
      }
      return query;
    }
    function maybeEncodeCPAResponse(data, config) {
      var _a;
      var includeContentSourceMaps = (_a = config === null || config === void 0 ? void 0 : config.params) === null || _a === void 0 ? void 0 : _a.includeContentSourceMaps;
      if (includeContentSourceMaps) {
        return ue(data);
      }
      return data;
    }
    function get(_x) {
      return _get.apply(this, arguments);
    }
    function _get() {
      _get = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee(_ref2) {
        var context, path, config, baseUrl, response;
        return _regeneratorRuntime$1.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              context = _ref2.context, path = _ref2.path, config = _ref2.config;
              baseUrl = getBaseUrl(context);
              _context.prev = 2;
              _context.next = 5;
              return http.get(baseUrl + path, config);
            case 5:
              response = _context.sent;
              return _context.abrupt("return", maybeEncodeCPAResponse(response.data, config));
            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](2);
              errorHandler(_context.t0);
            case 12:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 9]]);
      }));
      return _get.apply(this, arguments);
    }
    function post(_x2) {
      return _post.apply(this, arguments);
    }
    function _post() {
      _post = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee2(_ref3) {
        var context, path, data, config, baseUrl, response;
        return _regeneratorRuntime$1.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              context = _ref3.context, path = _ref3.path, data = _ref3.data, config = _ref3.config;
              baseUrl = getBaseUrl(context);
              _context2.prev = 2;
              _context2.next = 5;
              return http.post(baseUrl + path, data, config);
            case 5:
              response = _context2.sent;
              return _context2.abrupt("return", response.data);
            case 9:
              _context2.prev = 9;
              _context2.t0 = _context2["catch"](2);
              errorHandler(_context2.t0);
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[2, 9]]);
      }));
      return _post.apply(this, arguments);
    }
    function getSpace() {
      return _getSpace.apply(this, arguments);
    }
    function _getSpace() {
      _getSpace = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee3() {
        return _regeneratorRuntime$1.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", get({
                context: 'space',
                path: ''
              }));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      return _getSpace.apply(this, arguments);
    }
    function getContentType(_x3) {
      return _getContentType.apply(this, arguments);
    }
    function _getContentType() {
      _getContentType = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee4(id) {
        return _regeneratorRuntime$1.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", get({
                context: 'environment',
                path: "content_types/".concat(id)
              }));
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      return _getContentType.apply(this, arguments);
    }
    function getContentTypes() {
      return _getContentTypes.apply(this, arguments);
    }
    function _getContentTypes() {
      _getContentTypes = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee5() {
        var query,
          _args5 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              query = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};
              return _context5.abrupt("return", get({
                context: 'environment',
                path: 'content_types',
                config: createRequestConfig({
                  query: query
                })
              }));
            case 2:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));
      return _getContentTypes.apply(this, arguments);
    }
    function getEntry(_x4) {
      return _getEntry.apply(this, arguments);
    }
    function _getEntry() {
      _getEntry = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee6(id) {
        var query,
          _args6 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              query = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
              return _context6.abrupt("return", makeGetEntry(id, query, options));
            case 2:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      return _getEntry.apply(this, arguments);
    }
    function getEntries() {
      return _getEntries.apply(this, arguments);
    }
    function _getEntries() {
      _getEntries = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee7() {
        var query,
          _args7 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              query = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};
              return _context7.abrupt("return", makeGetEntries(query, options));
            case 2:
            case "end":
              return _context7.stop();
          }
        }, _callee7);
      }));
      return _getEntries.apply(this, arguments);
    }
    function makeGetEntry(_x5, _x6) {
      return _makeGetEntry.apply(this, arguments);
    }
    function _makeGetEntry() {
      _makeGetEntry = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee8(id, query) {
        var options,
          withAllLocales,
          _args8 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              options = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {
                withAllLocales: false,
                withoutLinkResolution: false,
                withoutUnresolvableLinks: false
              };
              withAllLocales = options.withAllLocales;
              validateLocaleParam(query, withAllLocales);
              validateResolveLinksParam(query);
              validateRemoveUnresolvedParam(query);
              validateSearchParameters(query);
              return _context8.abrupt("return", internalGetEntry(id, withAllLocales ? Object.assign(Object.assign({}, query), {
                locale: '*'
              }) : query, options));
            case 7:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      return _makeGetEntry.apply(this, arguments);
    }
    function internalGetEntry(_x7, _x8, _x9) {
      return _internalGetEntry.apply(this, arguments);
    }
    function _internalGetEntry() {
      _internalGetEntry = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee9(id, query, options) {
        var response;
        return _regeneratorRuntime$1.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              if (id) {
                _context9.next = 2;
                break;
              }
              throw notFoundError(id);
            case 2:
              _context9.prev = 2;
              _context9.next = 5;
              return internalGetEntries(Object.assign({
                'sys.id': id
              }, maybeEnableSourceMaps(query)), options);
            case 5:
              response = _context9.sent;
              if (!(response.items.length > 0)) {
                _context9.next = 10;
                break;
              }
              return _context9.abrupt("return", response.items[0]);
            case 10:
              throw notFoundError(id);
            case 11:
              _context9.next = 16;
              break;
            case 13:
              _context9.prev = 13;
              _context9.t0 = _context9["catch"](2);
              errorHandler(_context9.t0);
            case 16:
            case "end":
              return _context9.stop();
          }
        }, _callee9, null, [[2, 13]]);
      }));
      return _internalGetEntry.apply(this, arguments);
    }
    function makeGetEntries(_x10) {
      return _makeGetEntries.apply(this, arguments);
    }
    function _makeGetEntries() {
      _makeGetEntries = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee10(query) {
        var options,
          withAllLocales,
          _args10 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {
                withAllLocales: false,
                withoutLinkResolution: false,
                withoutUnresolvableLinks: false
              };
              withAllLocales = options.withAllLocales;
              validateLocaleParam(query, withAllLocales);
              validateResolveLinksParam(query);
              validateRemoveUnresolvedParam(query);
              validateSearchParameters(query);
              return _context10.abrupt("return", internalGetEntries(withAllLocales ? Object.assign(Object.assign({}, query), {
                locale: '*'
              }) : query, options));
            case 7:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      return _makeGetEntries.apply(this, arguments);
    }
    function internalGetEntries(_x11, _x12) {
      return _internalGetEntries.apply(this, arguments);
    }
    function _internalGetEntries() {
      _internalGetEntries = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee11(query, options) {
        var withoutLinkResolution, withoutUnresolvableLinks, entries;
        return _regeneratorRuntime$1.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              withoutLinkResolution = options.withoutLinkResolution, withoutUnresolvableLinks = options.withoutUnresolvableLinks;
              _context11.prev = 1;
              _context11.next = 4;
              return get({
                context: 'environment',
                path: 'entries',
                config: createRequestConfig({
                  query: maybeEnableSourceMaps(normalizeSearchParameters(normalizeSelect(query)))
                })
              });
            case 4:
              entries = _context11.sent;
              return _context11.abrupt("return", resolveCircular(entries, {
                resolveLinks: !withoutLinkResolution,
                removeUnresolved: withoutUnresolvableLinks !== null && withoutUnresolvableLinks !== void 0 ? withoutUnresolvableLinks : false
              }));
            case 8:
              _context11.prev = 8;
              _context11.t0 = _context11["catch"](1);
              errorHandler(_context11.t0);
            case 11:
            case "end":
              return _context11.stop();
          }
        }, _callee11, null, [[1, 8]]);
      }));
      return _internalGetEntries.apply(this, arguments);
    }
    function getAsset(_x13) {
      return _getAsset.apply(this, arguments);
    }
    function _getAsset() {
      _getAsset = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee12(id) {
        var query,
          _args12 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              query = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {};
              return _context12.abrupt("return", makeGetAsset(id, query, options));
            case 2:
            case "end":
              return _context12.stop();
          }
        }, _callee12);
      }));
      return _getAsset.apply(this, arguments);
    }
    function getAssets() {
      return _getAssets.apply(this, arguments);
    }
    function _getAssets() {
      _getAssets = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee13() {
        var query,
          _args13 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              query = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : {};
              return _context13.abrupt("return", makeGetAssets(query, options));
            case 2:
            case "end":
              return _context13.stop();
          }
        }, _callee13);
      }));
      return _getAssets.apply(this, arguments);
    }
    function makeGetAssets(_x14) {
      return _makeGetAssets.apply(this, arguments);
    }
    function _makeGetAssets() {
      _makeGetAssets = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee14(query) {
        var options,
          withAllLocales,
          localeSpecificQuery,
          _args14 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              options = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {
                withAllLocales: false,
                withoutLinkResolution: false,
                withoutUnresolvableLinks: false
              };
              withAllLocales = options.withAllLocales;
              validateLocaleParam(query, withAllLocales);
              validateSearchParameters(query);
              localeSpecificQuery = withAllLocales ? Object.assign(Object.assign({}, query), {
                locale: '*'
              }) : query;
              return _context14.abrupt("return", internalGetAssets(localeSpecificQuery));
            case 6:
            case "end":
              return _context14.stop();
          }
        }, _callee14);
      }));
      return _makeGetAssets.apply(this, arguments);
    }
    function internalGetAsset(_x15, _x16) {
      return _internalGetAsset.apply(this, arguments);
    }
    function _internalGetAsset() {
      _internalGetAsset = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee15(id, query) {
        return _regeneratorRuntime$1.wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              _context15.prev = 0;
              return _context15.abrupt("return", get({
                context: 'environment',
                path: "assets/".concat(id),
                config: createRequestConfig({
                  query: maybeEnableSourceMaps(normalizeSelect(query))
                })
              }));
            case 4:
              _context15.prev = 4;
              _context15.t0 = _context15["catch"](0);
              errorHandler(_context15.t0);
            case 7:
            case "end":
              return _context15.stop();
          }
        }, _callee15, null, [[0, 4]]);
      }));
      return _internalGetAsset.apply(this, arguments);
    }
    function makeGetAsset(_x17, _x18) {
      return _makeGetAsset.apply(this, arguments);
    }
    function _makeGetAsset() {
      _makeGetAsset = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee16(id, query) {
        var options,
          withAllLocales,
          localeSpecificQuery,
          _args16 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              options = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : {
                withAllLocales: false,
                withoutLinkResolution: false,
                withoutUnresolvableLinks: false
              };
              withAllLocales = options.withAllLocales;
              validateLocaleParam(query, withAllLocales);
              validateSearchParameters(query);
              localeSpecificQuery = withAllLocales ? Object.assign(Object.assign({}, query), {
                locale: '*'
              }) : query;
              return _context16.abrupt("return", internalGetAsset(id, localeSpecificQuery));
            case 6:
            case "end":
              return _context16.stop();
          }
        }, _callee16);
      }));
      return _makeGetAsset.apply(this, arguments);
    }
    function internalGetAssets(_x19) {
      return _internalGetAssets.apply(this, arguments);
    }
    function _internalGetAssets() {
      _internalGetAssets = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee17(query) {
        return _regeneratorRuntime$1.wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.prev = 0;
              return _context17.abrupt("return", get({
                context: 'environment',
                path: 'assets',
                config: createRequestConfig({
                  query: maybeEnableSourceMaps(normalizeSearchParameters(normalizeSelect(query)))
                })
              }));
            case 4:
              _context17.prev = 4;
              _context17.t0 = _context17["catch"](0);
              errorHandler(_context17.t0);
            case 7:
            case "end":
              return _context17.stop();
          }
        }, _callee17, null, [[0, 4]]);
      }));
      return _internalGetAssets.apply(this, arguments);
    }
    function getTag(_x20) {
      return _getTag.apply(this, arguments);
    }
    function _getTag() {
      _getTag = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee18(id) {
        return _regeneratorRuntime$1.wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              return _context18.abrupt("return", get({
                context: 'environment',
                path: "tags/".concat(id)
              }));
            case 1:
            case "end":
              return _context18.stop();
          }
        }, _callee18);
      }));
      return _getTag.apply(this, arguments);
    }
    function getTags() {
      return _getTags.apply(this, arguments);
    }
    function _getTags() {
      _getTags = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee19() {
        var query,
          _args19 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              query = _args19.length > 0 && _args19[0] !== undefined ? _args19[0] : {};
              validateSearchParameters(query);
              return _context19.abrupt("return", get({
                context: 'environment',
                path: 'tags',
                config: createRequestConfig({
                  query: normalizeSearchParameters(normalizeSelect(query))
                })
              }));
            case 3:
            case "end":
              return _context19.stop();
          }
        }, _callee19);
      }));
      return _getTags.apply(this, arguments);
    }
    function createAssetKey(_x21) {
      return _createAssetKey.apply(this, arguments);
    }
    function _createAssetKey() {
      _createAssetKey = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee20(expiresAt) {
        var now, currentMaxLifetime;
        return _regeneratorRuntime$1.wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              try {
                now = Math.floor(Date.now() / 1000);
                currentMaxLifetime = now + ASSET_KEY_MAX_LIFETIME;
                validateTimestamp('expiresAt', expiresAt, {
                  maximum: currentMaxLifetime,
                  now: now
                });
              } catch (error) {
                errorHandler(error);
              }
              return _context20.abrupt("return", post({
                context: 'environment',
                path: 'asset_keys',
                data: {
                  expiresAt: expiresAt
                }
              }));
            case 2:
            case "end":
              return _context20.stop();
          }
        }, _callee20);
      }));
      return _createAssetKey.apply(this, arguments);
    }
    function getLocales() {
      return _getLocales.apply(this, arguments);
    }
    function _getLocales() {
      _getLocales = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee21() {
        var query,
          _args21 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              query = _args21.length > 0 && _args21[0] !== undefined ? _args21[0] : {};
              validateSearchParameters(query);
              return _context21.abrupt("return", get({
                context: 'environment',
                path: 'locales',
                config: createRequestConfig({
                  query: normalizeSelect(query)
                })
              }));
            case 3:
            case "end":
              return _context21.stop();
          }
        }, _callee21);
      }));
      return _getLocales.apply(this, arguments);
    }
    function sync(_x22) {
      return _sync.apply(this, arguments);
    }
    function _sync() {
      _sync = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee22(query) {
        var syncOptions,
          _args22 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              syncOptions = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : {
                paginate: true
              };
              return _context22.abrupt("return", makePagedSync(query, syncOptions, options));
            case 2:
            case "end":
              return _context22.stop();
          }
        }, _callee22);
      }));
      return _sync.apply(this, arguments);
    }
    function makePagedSync(_x23, _x24) {
      return _makePagedSync.apply(this, arguments);
    }
    function _makePagedSync() {
      _makePagedSync = _asyncToGenerator$1(/*#__PURE__*/_regeneratorRuntime$1.mark(function _callee23(query, syncOptions) {
        var options,
          combinedOptions,
          _args23 = arguments;
        return _regeneratorRuntime$1.wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              options = _args23.length > 2 && _args23[2] !== undefined ? _args23[2] : {
                withAllLocales: false,
                withoutLinkResolution: false,
                withoutUnresolvableLinks: false
              };
              validateResolveLinksParam(query);
              validateRemoveUnresolvedParam(query);
              combinedOptions = Object.assign(Object.assign({}, syncOptions), options);
              switchToEnvironment(http);
              return _context23.abrupt("return", pagedSync(http, query, combinedOptions));
            case 6:
            case "end":
              return _context23.stop();
          }
        }, _callee23);
      }));
      return _makePagedSync.apply(this, arguments);
    }
    function parseEntries(data) {
      return makeParseEntries(data, options);
    }
    function makeParseEntries(data) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        withAllLocales: false,
        withoutLinkResolution: false,
        withoutUnresolvableLinks: false
      };
      return internalParseEntries(data, options);
    }
    function internalParseEntries(data, options) {
      var withoutLinkResolution = options.withoutLinkResolution,
        withoutUnresolvableLinks = options.withoutUnresolvableLinks;
      return resolveCircular(data, {
        resolveLinks: !withoutLinkResolution,
        removeUnresolved: withoutUnresolvableLinks !== null && withoutUnresolvableLinks !== void 0 ? withoutUnresolvableLinks : false
      });
    }
    /*
     * Switches BaseURL to use /environments path
     * */
    function switchToEnvironment(http) {
      http.defaults.baseURL = getGlobalOptions().environmentBaseUrl;
    }
    return {
      version: "11.2.0",
      getSpace: getSpace,
      getContentType: getContentType,
      getContentTypes: getContentTypes,
      getAsset: getAsset,
      getAssets: getAssets,
      getTag: getTag,
      getTags: getTags,
      getLocales: getLocales,
      parseEntries: parseEntries,
      sync: sync,
      getEntry: getEntry,
      getEntries: getEntries,
      createAssetKey: createAssetKey
    };
  }

  function create(_ref, options, makeInnerClient) {
    var http = _ref.http,
      getGlobalOptions = _ref.getGlobalOptions;
    var client = createContentfulApi({
      http: http,
      getGlobalOptions: getGlobalOptions
    }, options);
    var response = client ? client : {};
    Object.defineProperty(response, 'withAllLocales', {
      get: function get() {
        return makeInnerClient(Object.assign(Object.assign({}, options), {
          withAllLocales: true
        }));
      }
    });
    Object.defineProperty(response, 'withoutLinkResolution', {
      get: function get() {
        return makeInnerClient(Object.assign(Object.assign({}, options), {
          withoutLinkResolution: true
        }));
      }
    });
    Object.defineProperty(response, 'withoutUnresolvableLinks', {
      get: function get() {
        return makeInnerClient(Object.assign(Object.assign({}, options), {
          withoutUnresolvableLinks: true
        }));
      }
    });
    return Object.create(response);
  }
  var makeClient = function makeClient(_ref2) {
    var http = _ref2.http,
      getGlobalOptions = _ref2.getGlobalOptions;
    function makeInnerClient(options) {
      return create({
        http: http,
        getGlobalOptions: getGlobalOptions
      }, options, makeInnerClient);
    }
    var client = createContentfulApi({
      http: http,
      getGlobalOptions: getGlobalOptions
    }, {
      withoutLinkResolution: false,
      withAllLocales: false,
      withoutUnresolvableLinks: false
    });
    return Object.assign(Object.assign({}, client), {
      get withAllLocales() {
        return makeInnerClient({
          withAllLocales: true,
          withoutLinkResolution: false,
          withoutUnresolvableLinks: false
        });
      },
      get withoutLinkResolution() {
        return makeInnerClient({
          withAllLocales: false,
          withoutLinkResolution: true,
          withoutUnresolvableLinks: false
        });
      },
      get withoutUnresolvableLinks() {
        return makeInnerClient({
          withAllLocales: false,
          withoutLinkResolution: false,
          withoutUnresolvableLinks: true
        });
      }
    });
  };

  /**
   * Contentful Delivery API SDK. Allows you to create instances of a client
   * with access to the Contentful Content Delivery API.
   */
  /**
   * Create a client instance
   * @param params - Client initialization parameters
   * @category Client
   * @example
   * ```typescript
   * const contentful = require('contentful')
   * const client = contentful.createClient({
   *   accessToken: 'myAccessToken',
   *   space: 'mySpaceId'
   * })
   * ```
   */
  function createClient(params) {
    if (!params.accessToken) {
      throw new TypeError('Expected parameter accessToken');
    }
    if (!params.space) {
      throw new TypeError('Expected parameter space');
    }
    validateResolveLinksParam(params);
    validateRemoveUnresolvedParam(params);
    var defaultConfig = {
      resolveLinks: true,
      removeUnresolved: false,
      defaultHostname: 'cdn.contentful.com',
      environment: 'master'
    };
    var config = Object.assign(Object.assign({}, defaultConfig), params);
    var userAgentHeader = getUserAgentHeader("contentful.js/".concat("11.2.0"), config.application, config.integration);
    config.headers = Object.assign(Object.assign({}, config.headers), {
      'Content-Type': 'application/vnd.contentful.delivery.v1+json',
      'X-Contentful-User-Agent': userAgentHeader
    });
    var http = createHttpClient(axios$1, config);
    if (!http.defaults.baseURL) {
      throw new Error('Please define a baseURL');
    }
    var getGlobalOptions = createGlobalOptions({
      space: config.space,
      environment: config.environment,
      spaceBaseUrl: http.defaults.baseURL,
      environmentBaseUrl: "".concat(http.defaults.baseURL, "environments/").concat(config.environment)
    });
    // Append environment to baseURL
    http.defaults.baseURL = getGlobalOptions({}).environmentBaseUrl;
    return makeClient({
      http: http,
      getGlobalOptions: getGlobalOptions
    });
  }

  exports.createClient = createClient;
  exports.createGlobalOptions = createGlobalOptions;

  return exports;

})({});
